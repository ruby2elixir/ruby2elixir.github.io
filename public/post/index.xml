<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ruby 2 Elixir Blog</title>
    <link>http://ruby2elixir.github.io/post.html</link>
    <description>Recent content in Posts on Ruby 2 Elixir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 04 Feb 2016 18:36:00 +0100</lastBuildDate>
    <atom:link href="http://ruby2elixir.github.io/post.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Setting Up Drone.io CI for Elixir and Phoenix</title>
      <link>http://ruby2elixir.github.io/posts/2016/02-04-setting-up-drone.io-ci-for-elixir-and-phoenix.html</link>
      <pubDate>Thu, 04 Feb 2016 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2016/02-04-setting-up-drone.io-ci-for-elixir-and-phoenix.html</guid>
      <description>

&lt;p&gt;Running your CI tests for opensource project on Travis.Ci seems like a no-brainer. Travis offers quite robust integration into Github and boasts with impressive feature set, that&amp;rsquo;s flexible and very convenient.&lt;/p&gt;

&lt;p&gt;But their offering for private projects is kinda steep, especially when you&amp;rsquo;re just starting out, like Steve Domin recently noticed.&lt;/p&gt;

&lt;!-- &lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Wow, first &lt;a href=&#34;https://twitter.com/travisci&#34;&gt;@travisci&lt;/a&gt; paid plan starts at $129/mo. Definitely not an option for personal projects&lt;/p&gt;&amp;mdash; Steve Domin (@stevedomin) &lt;a href=&#34;https://twitter.com/stevedomin/status/695173772740026368&#34;&gt;February 4, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt; --&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/tweet_travisci_private_expensive.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;There are some great hosted alternatives that are cheaper and might work for you, like&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://buddy.works/pricing&#34;&gt;https://buddy.works/pricing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://semaphoreci.com/pricing&#34;&gt;https://semaphoreci.com/pricing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://circleci.com/pricing/&#34;&gt;https://circleci.com/pricing/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://drone.io/pricing&#34;&gt;https://drone.io/pricing&lt;/a&gt; -&amp;gt; less expensive than jenkins+ec2&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Then there is always your trusted &lt;a href=&#34;https://jenkins-ci.org/&#34;&gt;Jenkins&lt;/a&gt; for old-style control-freaks, who like to host everything themselves.&lt;/p&gt;

&lt;p&gt;Is there another opensource solution?&lt;/p&gt;

&lt;p&gt;Indeed, there is. &lt;a href=&#34;https://drone.io/&#34;&gt;Drone.io&lt;/a&gt; (the last one in the alternatives list) also offers an &lt;a href=&#34;http://readme.drone.io/&#34;&gt;opensource version&lt;/a&gt; that you can host yourself. It was just recently endowed with a really cool matrix build feature.&lt;/p&gt;

&lt;!-- &lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Drone 0.4 has been released! Improved plugins, matrix builds, composed service containers &lt;a href=&#34;https://t.co/m3v4O5ibLJ&#34;&gt;https://t.co/m3v4O5ibLJ&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/docker?src=hash&#34;&gt;#docker&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/ci?src=hash&#34;&gt;#ci&lt;/a&gt;&lt;/p&gt;&amp;mdash; drone.io (@droneio) &lt;a href=&#34;https://twitter.com/droneio/status/689842872632246272&#34;&gt;January 20, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt; --&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/tweet_droneio_matrix_build.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;The information about it is scattered around and is sometimes a bit outdated, so here are some links to get you started:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://twitter.com/droneio&#34;&gt;https://twitter.com/droneio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.drone.io/&#34;&gt;http://blog.drone.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://readme.drone.io/&#34;&gt;http://readme.drone.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Today we&amp;rsquo;re going to setup a CI for a Phoenix project hosted on Github (or Bitbucket, both at same time is not possible) with a ridiculous fast turn-around time and total cost of 10$/m + some initial time investment.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s gonna be a fun and rewarding experience, so let&amp;rsquo;s get started!&lt;/p&gt;

&lt;h3 id=&#34;requirements:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Requirements&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://digitalocean.com&#34;&gt;DigitalOcean account&lt;/a&gt; &amp;ndash;&amp;gt; &lt;a href=&#34;https://m.do.co/c/2f7f898f4040&#34;&gt;Get 10$ credit on signing up (referral link)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github account / Bitbucket account&lt;/li&gt;
&lt;li&gt;A Phoenix application, that you want to run CI for&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;setup-digital-ocean:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Setup Digital Ocean&lt;/h3&gt;

&lt;p&gt;We could cheat here and just install one of the provides App-Images on Digital Ocean:&lt;/p&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_digital_ocean_pick_one_click_vm.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;hr&gt;

&lt;p&gt;If you want to have more details, it&amp;rsquo;s not that hard to install the real thing on a plain Ubuntu VM (&amp;gt; 14.04).&lt;/p&gt;

&lt;h4 id=&#34;install-docker-following-the-instructions-here-https-docs-docker-com-engine-installation-ubuntulinux:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Install Docker following the instructions here: &lt;a href=&#34;https://docs.docker.com/engine/installation/ubuntulinux/&#34;&gt;https://docs.docker.com/engine/installation/ubuntulinux/&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;## we assume Ubuntu Trusty 14.04
# update APT sources
$ sudo apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D
$ sudo touch /etc/apt/sources.list.d/docker.list
$ sudo echo &amp;quot;deb https://apt.dockerproject.org/repo ubuntu-trusty main&amp;quot; &amp;gt; /etc/apt/sources.list.d/docker.list

## update sources
$ apt-get update

## install docker
$ sudo apt-get install docker-engine

## start docker daemon
$ sudo service docker start

## test that it was installed
$ sudo docker run hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;install-drone-io-following-the-instructions-here-http-readme-drone-io-setup-overview:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Install Drone.io following the instructions here: &lt;a href=&#34;http://readme.drone.io/setup/overview/&#34;&gt;http://readme.drone.io/setup/overview/&lt;/a&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo docker pull drone/drone:0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;configure-github-application:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Configure Github Application&lt;/h4&gt;

&lt;p&gt;Github Setting -&amp;gt; Applications -&amp;gt; Developer Applications (&lt;a href=&#34;https://github.com/settings/developers&#34;&gt;https://github.com/settings/developers&lt;/a&gt;)&lt;/p&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_github_register_new_application.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;ul&gt;
&lt;li&gt;Application Name: Drone CI&lt;/li&gt;
&lt;li&gt;Homepage URL: IP from you DO Droplet, like: &lt;a href=&#34;http://111.11.111.11/&#34;&gt;http://111.11.111.11/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Authorization callback URL: &lt;a href=&#34;http://111.11.111.11/authorize&#34;&gt;http://111.11.111.11/authorize&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_github_application_data.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;h4 id=&#34;contunue-drone-io-configuration:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Contunue Drone.io Configuration&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ sudo mkdir -p /etc/drone/
$ sudo vim /etc/drone/dronerc
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-vim&#34;&gt;REMOTE_DRIVER=github
REMOTE_CONFIG=https://github.com?client_id=XXXX&amp;amp;client_secret=XXXX
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# now start your Drone.io container
sudo docker run \
  --volume /var/lib/drone:/var/lib/drone \
  --volume /var/run/docker.sock:/var/run/docker.sock \
  --env-file /etc/drone/dronerc \
  --restart=always \
  --publish=80:8000 \
  --detach=true \
  --name=drone \
  drone/drone:0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Open in the browser the IP of your Drone DO Droplet and after a short authorization you will be greated with a list of your projects on Github.&lt;/p&gt;

&lt;h3 id=&#34;auth-github:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Auth Github&lt;/h3&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_github_drone_authorization.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;h3 id=&#34;list-of-projects:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;List of projects&lt;/h3&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_projects_dropdown.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;h3 id=&#34;configure-a-phoenix-project-to-work-with-drone:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;Configure a Phoenix project to work with Drone&lt;/h3&gt;

&lt;p&gt;Now we are ready to setup our project to run on Drone.io. In similar fashion to Travis.ci it reads its configuration from a YAML file named  &lt;code&gt;.drone.yml&lt;/code&gt; in the root of the project.&lt;/p&gt;

&lt;p&gt;The simplest config for an Elixir project would look like that:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat .drone.yml
build:
  image: bitwalker/alpine-elixir-phoenix:2.0
  commands:
    - mix deps.get
    - mix test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be enough to run a tests for a simple library.&lt;/p&gt;

&lt;p&gt;To run tests for a &lt;strong&gt;Phoenix project&lt;/strong&gt; we need to specify a little bit more.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;d like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a Postgres database server&lt;/li&gt;
&lt;li&gt;caching for dependencies (so we don&amp;rsquo;t have to compile them everytime our build runs)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also in the current version of Ecto (1.1.3 ) it relies on &lt;strong&gt;psql&lt;/strong&gt; binary to be present to run the mix commands for DB creation + DB migration.&lt;/p&gt;

&lt;p&gt;This dependency will be removed in the upcoming version 2.0, see pull request: &lt;a href=&#34;https://github.com/elixir-lang/ecto/pull/1163&#34;&gt;https://github.com/elixir-lang/ecto/pull/1163&lt;/a&gt; - Switch pg storage management away from psql&lt;/p&gt;

&lt;p&gt;To make it even more interesting we&amp;rsquo;re gonna use an umbrella project with two Phoenix apps with different DB configurations. Somehow there is a bug here, so that the &lt;strong&gt;ecto.migrate&lt;/strong&gt; for one of the databases is not executed during a normal &lt;strong&gt;mix test&lt;/strong&gt; run. As a workaround I run the commands explicitly before tests.&lt;/p&gt;

&lt;p&gt;So, to recap:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;install postgresql-client (so psql is present)&lt;/li&gt;
&lt;li&gt;run ecto.migrate for both test DBs&lt;/li&gt;
&lt;li&gt;use PosgreSQL Docker image in compose block&lt;/li&gt;
&lt;li&gt;cache the dependencies + the _build folder (maybe too fragile, needs real life experience over longer time&amp;hellip;)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cat .drone.yml
cache:
  mount:
    - _build
    - deps

build:
  image: bitwalker/alpine-elixir-phoenix:2.0
  commands:
    - apk update
    - apk add postgresql-client
    - mix deps.get
    - MIX_ENV=test mix ecto.create  -r Back.Repo
    - MIX_ENV=test mix ecto.migrate -r Back.Repo
    - MIX_ENV=test mix ecto.create ecto.migrate -r Front.Repo
    - mix test

compose:
  database:
    image: postgres:9.5
    environment:
    - POSTGRES_USER=postgres
    - POSTGRES_PASSWORD=postgres
    - POSTGRES_DB=postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is the example application, that we&amp;rsquo;re going to test - &lt;a href=&#34;https://github.com/ruby2elixir/phoenix_crud_benchmark_60_controllers&#34;&gt;https://github.com/ruby2elixir/phoenix_crud_benchmark_60_controllers&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;It executes full real CRUD controller tests for 60 controllers in one application.&lt;/p&gt;

&lt;p&gt;An uncached initial CI test takes something around 2 minutes.









&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_drone_uncached_run.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;After we have some &amp;ldquo;warm&amp;rdquo; caches, it takes less than 1m 15sec to get feedback. For 60 real controllers with DB tests ;)&lt;/p&gt;

&lt;p&gt;








&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_failed_build_with_timing.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;










&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2016/drone_setup_fixed_build_with_timing.png&#34;

    
     width=&#34;550&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Those initial results make me smile. A broken build in the evening is much faster to fix if it takes only a few minutes to get the results back.&lt;/p&gt;

&lt;p&gt;Also you don&amp;rsquo;t have to break the bank to foster best practices for running Continious Integration on a tight budget.&lt;/p&gt;

&lt;p&gt;Please leave any feedback whether you&amp;rsquo;ve found that article helpful or if there are some improvements / mistakes.&lt;/p&gt;

&lt;p&gt;Best,
Roman&lt;/p&gt;

&lt;hr&gt;

&lt;h4 id=&#34;more-links-about-drone-io:b11a2c73716529ff1d7a5a8613a5808d&#34;&gt;More links about Drone.io:&lt;/h4&gt;

&lt;p&gt;Plugins:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://addons.drone.io/&#34;&gt;http://addons.drone.io/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/drone-plugins&#34;&gt;https://github.com/drone-plugins&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Community:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gitter.im/drone/drone&#34;&gt;https://gitter.im/drone/drone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://discuss.drone.io/&#34;&gt;https://discuss.drone.io/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Examples:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/drone-demos/drone-with-elixir&#34;&gt;https://github.com/drone-demos/drone-with-elixir&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Webpack Hot-Reloading with Phoenix</title>
      <link>http://ruby2elixir.github.io/posts/2016/01-14-webpack-hot-reloading-with-phoenix.html</link>
      <pubDate>Thu, 14 Jan 2016 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2016/01-14-webpack-hot-reloading-with-phoenix.html</guid>
      <description>

&lt;blockquote&gt;
  this is just a reminder without proper comments...
&lt;/blockquote&gt;

&lt;h3 id=&#34;steps-to-enable-webpack-hot-reloding-in-phoenix:4265bc156c36d01e73c56df1cd691262&#34;&gt;Steps to enable Webpack + hot-reloding in Phoenix:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Router: add routes for webpack controller (proxy)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;if Mix.env == :dev do
  scope &amp;quot;/static&amp;quot;, Front do
    pipe_through :api
    get &amp;quot;/:req&amp;quot;, WebPackController, :hot_update
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Webpack Proxy Controller (web/controllers/web_pack_controller.ex)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Front.WebPackController do
  use Phoenix.Controller
  @webpack_url &amp;quot;http://localhost:3000/static/&amp;quot;

  def hot_update(conn, params) do
    req = Map.get(params, &amp;quot;req&amp;quot;)
    res = HTTPoison.get! @webpack_url &amp;lt;&amp;gt; req
    text conn, res.body
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Endpoint: adjust static Plug to include webpack&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;    plug Plug.Static,
      at: &amp;quot;/&amp;quot;, from: :back, gzip: false,
      only: ~w(css fonts images js webpack favicon.ico robots.txt)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Config: dev.exs - configure watchers:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;webpack_args = [Path.expand(&amp;quot;assets/node_modules/.bin/webpack-dev-server&amp;quot;),
    &amp;quot;--port=3000&amp;quot;,
    &amp;quot;--history-api-fallback&amp;quot;,
    &amp;quot;--hot&amp;quot;,
    &amp;quot;--progress&amp;quot;,
    &amp;quot;--inline&amp;quot;,
    &amp;quot;--colors&amp;quot;,
    &amp;quot;--stdin&amp;quot;, ## so it will stop, when stdin from phoenix is closed
               ## requires  https://github.com/webpack/webpack-dev-server/pull/352/files --&amp;gt; stdin, so probably &amp;gt;= 1.14.2
]
if IEx.started?, do: webpack_args = List.delete(webpack_args, &amp;quot;--progress&amp;quot;)

config :front, Front.Endpoint,
  http: [port: 4000],
  debug_errors: true,
  code_reloader: true,
  check_origin: false,
  root: Path.expand(&amp;quot;..&amp;quot;, __DIR__) &amp;lt;&amp;gt; &amp;quot;/assets&amp;quot;, #we need to be in the assets folder...
  watchers: [
    &amp;quot;node&amp;quot;: webpack_args,
  ]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Mix: add task for asset digesting (lib/mix/tasks.ex)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Mix.Tasks.MyApp.Digest do
  use Mix.Task

  def run(args) do
    Mix.Shell.IO.cmd &amp;quot;cd assets &amp;amp;&amp;amp; npm run build&amp;quot;
    :ok = Mix.Tasks.Phoenix.Digest.run(args)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;in mix.exs
defp aliases do
  [
    ....#
    &amp;quot;phoenix.digest&amp;quot;: [&amp;quot;my_app.digest&amp;quot;]
  ]
end

# add :httpoison to be started
defp applications(:dev) do
  [:httpoison] + applications(:prod)
end

defp applications(_) do
  [....]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Views

&lt;ul&gt;
&lt;li&gt;layout_view.ex&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-elixir&#34;&gt;defmodule Front.LayoutView do
  use Front.Web, :view

  def styles_bundle(conn) do
    make_path(conn, &amp;quot;vendor_styles-bundle.js&amp;quot;)
  end

  def js_bundle(conn) do
    make_path(conn, &amp;quot;js-bundle.js&amp;quot;)
  end

  # enables hot-reloadable URLs in development
  defp make_path(conn, asset) do
    if Mix.env == :dev do
      &amp;quot;http://localhost:3000/static/&amp;quot; &amp;lt;&amp;gt; asset
    else
      Front.Router.Helpers.static_path(conn, &amp;quot;/webpack/&amp;quot; &amp;lt;&amp;gt; asset)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;templates:
  - use helpers in layout&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;meta http-equiv=&amp;quot;X-UA-Compatible&amp;quot; content=&amp;quot;IE=edge&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;description&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;meta name=&amp;quot;author&amp;quot; content=&amp;quot;&amp;quot;&amp;gt;

    &amp;lt;title&amp;gt;Front - React&amp;lt;/title&amp;gt;
    &amp;lt;script src=&amp;quot;&amp;lt;%= styles_bundle(@conn) %&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;quot;root&amp;quot; class=&amp;quot;container&amp;quot;&amp;gt;
    &amp;lt;/div&amp;gt; &amp;lt;!-- /container --&amp;gt;
    &amp;lt;script src=&#39;&amp;lt;%= js_bundle(@conn) %&amp;gt;&#39;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;gotchas:4265bc156c36d01e73c56df1cd691262&#34;&gt;Gotchas:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;Error: ENOENT: no such file or directory, open &#39;.../node_modules/webpack-dev-server/client/live.bundle.js&#39;
at Error (native)

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpack/webpack-dev-server/issues/59&#34;&gt;https://github.com/webpack/webpack-dev-server/issues/59&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd node_modules/webpack-dev-server &amp;amp;&amp;amp; npm run-script prepublish
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>What makes Elixir so attractive for some developers?</title>
      <link>http://ruby2elixir.github.io/posts/2015/12-29-what-makes-elixir-so-attractive-for-some-developers.html</link>
      <pubDate>Tue, 29 Dec 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/12-29-what-makes-elixir-so-attractive-for-some-developers.html</guid>
      <description>

&lt;p&gt;
  EDIT: I&#39;ll keep updating this list with recent posts / stories.
&lt;/p&gt;
&lt;p&gt;
Before 2015 is over I decided to compile a list from developers who are excited to work with Elixir and what problems does it solve for them.
&lt;/p&gt;
&lt;p&gt;
The list is chronologically sorted from most recent to oldest articles. I hope this will be useful for anybody thinking what new programming language  to try in 2016.

&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;2016&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#sorentwo&#34;&gt;sorentwo.com - Caching, What is it Good For? - by Parker Selbert (&lt;sup&gt;2016&lt;/sup&gt;&amp;frasl;&lt;sub&gt;02&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#qertoip&#34;&gt;Piotr Włodarek - Elixir obsoletes Ruby, Erlang and Clojure in one go (&lt;sup&gt;2016&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#madebymany&#34;&gt;Stuart Eccles - What I learned migrating a Rails app to Elixir/Phoenix (&lt;sup&gt;2016&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2015&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#amber&#34;&gt;AmberBit - When to choose Elixir over Ruby for 2016 projects? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#akita&#34;&gt;Fabio Akita - The Obligatory “Why Elixir?” Personal Take (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#clark-kampfe&#34;&gt;Clark Kampfe - Elixir is not Ruby (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#john-orford&#34;&gt;John Orford - 10 Reasons To Use Elixir In Finance (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#david-cristofaro&#34;&gt;David Cristofaro - Drinking the Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#jerel-unruh&#34;&gt;Jerel Unruh - Why I&amp;rsquo;m excited about Elixir and Phoenix (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#rob-conery&#34;&gt;Rob Conery - Hello Elixir. Wow. (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#chris-nelson&#34;&gt;Chris Nelson -  4 Reasons We’re Having Fun Programming Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#luc-fueston&#34;&gt;Luc Fueston - The (Real) Reason I Like Elixir  (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#luke-imhoff&#34;&gt;Luke Imhoff - Why Elixir? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#jan-dudulski&#34;&gt;Jan Dudulski - We all are going to meet in the Elixir world (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#aaron-lebo&#34;&gt;Aaron Lebo - The UNIX Philosophy and Elixir as an Alternative to Go (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#lau-taarnskov&#34;&gt;Lau Taarnskov - Elixir - The next big language for the web (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;) &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#josh-smith&#34;&gt;Josh Smith - Functional parallel programming in Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#ken-mazaika&#34;&gt;Ken Mazaika - Why I’m betting on Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2014&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#paul-schoenfelder&#34;&gt;Paul Schoenfelder - What Is Elixir, and Why Do I Care? (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#sasa-juric&#34;&gt;Saša Jurić -  Why Elixir  (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#renderedtext&#34;&gt;Darko Fabijan -  Learn Elixir to stay young  (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;2013&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#alexei-sholik&#34;&gt;Alexei Sholik - Introducing Elixir (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;08&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#devin-torres&#34;&gt;Devin Torres - Elixir: It’s Not About Syntax (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;hr&gt;&lt;/p&gt;

&lt;h4 id=&#34;sorentwo&#34;&gt;Sorentwo - Caching, What is it Good For? - by Parker Selbert (2016/02) - &lt;a href=&#34;http://sorentwo.com/2016/02/02/caching-what-is-it-good-for.html&#34;&gt;http://sorentwo.com/2016/02/02/caching-what-is-it-good-for.html&lt;/a&gt;&lt;/h4&gt;
Parker Selbert is a webdeveloper with extensive knowledge about tuning Rails apps. Recently he has build a production system with Elixir and shares his experience.


&lt;blockquote&gt;
  The fact is, caching makes systems more complicated. Expiration and eviction strategies require planning, foresight, and maintenance. Caching adds additional dependencies in the form of database(s) that store all the cached data. It adds more libraries dedicated to caching and communication with said external cache. Finally, it makes personalizing content unwieldy, rarely worth the extra effort. All this extra effort is only necessary when a language can’t do the heavy lifting for you.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  For years I’ve been following the development of Elixir and using it for hobby projects. Only recently have I gotten the opportunity to build production systems with it. Now I’m completely spoiled. While I can espouse praise for the language, functional programming, the beauty of pattern matching, and the brilliance of the BEAM all day…that probably won’t be convincing. Instead, I’ll share a few benchmarks that emphasize the performance gulf between Ruby systems and an Elixir system.
&lt;/blockquote&gt;
...

&lt;blockquote&gt;
  These response times are not characteristic of either system, they are at the extreme upper limit. Even so, serving up &lt;strong&gt;2.5x the records with 4.5x the data, without any caching&lt;/strong&gt;, the Phoenix API response times are &lt;strong&gt;1.5x-2.5x&lt;/strong&gt; faster.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  For several years I focused my effort on squeezing performance out of caching and serialization in the Ruby world. The libraries I’ve built have been benchmarked and micro-tuned to attain what felt like blazing fast response times. On top of the work put into the libraries there was substantial overhead in constructing APIs to work within the confines of caching. As it turns out, those response times weren’t so blazing fast after all.
&lt;/blockquote&gt;


&lt;hr&gt;




&lt;h4 id=&#34;qertoip&#34;&gt;Piotr Włodarek - Elixir obsoletes Ruby, Erlang and Clojure in one go (2016/01) - &lt;a href=&#34;https://medium.com/@qertoip/elixir-obsoletes-ruby-erlang-and-clojure-in-one-go-605329b7b9b4#.3bptutvmt&#34;&gt;https://medium.com/@qertoip/elixir-obsoletes-ruby-erlang-and-clojure-in-one-go-605329b7b9b4#.3bptutvmt&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Piotr Włodarek was a happy Ruby programmer and evangelist since 2005, Clojure fan since 2008 and has dabbled with Erlang in 2007.&lt;/p&gt;

&lt;blockquote&gt;
  Recently I’ve come to conclusion all these languages are now obsolete.
  In a surprising twist Elixir supersedes all of them by delivering extremely well thought out mix of characteristics and features.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  Elixir is simply the first language since Ruby to really care about code beauty and UX of the language, libraries and ecosystem. Whether Elixir’s UX is slightly better or still slightly worse than Ruby’s is a matter of a debate. The thing is, it is definitely in the same league and should be (at least!) acceptable for a demanding Ruby programmer.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  Why care about massive concurrency in the first place? Rails apps we’ve been writing for the last ten years work just fine… Except they don’t once we enter the real-time web / IoT era.
&lt;/blockquote&gt;
...

&lt;blockquote&gt;
  &lt;h3&gt;Functional yet practical&lt;/h3&gt;
  Elixir is among the most practical functional languages to date. It cherry-picked some of the best Clojure features — efficient, immutable data structures, optional lazy evaluation, protocols and records. Contrary to Clojure it also enjoys true tail call optimization and the pipeline operator. Finally, it has a pleasant, modern, Ruby-like syntax, a rare gem among functional languages.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;Full macro system&lt;/h3&gt;
  Elixir is close to being homoiconic. Everyday syntax is a just bit of sugar on top of Elixir data structures. The way from code to its representation is direct and clear. Elixir supports full macros known from Lisp and Clojure without the torture of parentheses-driven syntax.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;Summary&lt;/h3&gt;
  Why would you choose Ruby over Elixir? Certainly mature libraries give Ruby huge productivity boost and are the only possible reason to still consider Ruby over Elixir. But it gets less and less important every day as Elixir packages pop-up like gems in Ruby’s golden era. What about Rails? Well, there is an excellent Phoenix contender.
  Why would you choose Clojure over Elixir? It’s really hard to justify except when you need to run on JVM for other reasons.
  Why would you choose Erlang over Elixir? You wouldn’t. Elixir is an almost-strict superset of Erlang’s offering.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;h4 id=&#34;madebymany&#34;&gt;Stuart Eccles - What I learned migrating a Rails app to Elixir/Phoenix (2016/01) &lt;a href=&#34;https://medium.com/@stueccles/what-i-learned-migrating-a-rails-app-to-elixir-phoenix-f707436749aa#.y03lsf9ln&#34;&gt;https://medium.com/@stueccles/what-i-learned-migrating-a-rails-app-to-elixir-phoenix-f707436749aa#.y03lsf9ln&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Stuart Eccles is CTO and Co-Founder of digital product innovation accelerator @madebymany making new stuff out of the internet.&lt;/p&gt;

&lt;blockquote&gt;
  I’ve been keen on Elixir for a while now. For us at Made by Many the promise of the productivity of Ruby without compromising on raw performance and scalability is rapidly making it a prime candidate for our go-to server-side language of choice.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;Lose the Object Orientated mindset, especially around models.&lt;/h3&gt;
  You are thinking in small functions that you string together. Once you make the transition I’ve found it is actually easier to understand what is going on. There is just a lot less magic to wrap your head around.
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;There are some integrations you are going to have to write yourself&lt;/h3&gt;
  The Elixir ecosystem isn’t developed to a point where there are libraries to integrate with every service you may use. You might have to roll up your sleeves to make that integration library yourself. But this is how we grow the ecosystem.
  There are also far fewer utility extension and helper libraries available for Phoenix but so far I’ve found that language features do a lot to overcome this.
&lt;/blockquote&gt;
...

&lt;blockquote&gt;
  &lt;h3&gt;Some things should just be done completely differently in Elixir/Phoenix&lt;/h3&gt;
  There are some software design patterns you just should do differently when creating an Elixir app.
  For instance when you think asynchronous, (...) you can just wrap a function in a Task.async or create your own OTP application
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;No Scope&lt;/h3&gt;
  Ecto doesn’t use scopes. Instead we use a pattern of storing queries in the module and then composing them when needed, see http://blog.drewolson.org/composable-queries-ecto/
&lt;/blockquote&gt;
...
&lt;blockquote&gt;
  &lt;h3&gt;Summary&lt;/h3&gt;
  So i’m sure there will be many more transition patterns that are useful in migrating a Rails app but so far I’ve found the process not only pretty painless but also feels vastly superior. Not to mention just how much faster the Elixir app is; response times under 100ms bring joy to the heart.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;h4 id=&#34;amber&#34;&gt;Ruby team at AmberBit  - Announcing Elixir Cocktails + When to choose Elixir over Ruby for 2016 projects?&lt;/h4&gt;
- &lt;a href=&#34;https://www.amberbit.com/blog/2015/7/24/announcing-elixir-cocktails/&#34;&gt;https://www.amberbit.com/blog/2015/7/24/announcing-elixir-cocktails/&lt;/a&gt;
- &lt;a href=&#34;https://www.amberbit.com/blog/2015/12/22/when-choose-elixir-over-ruby-for-2016-projects&#34;&gt;https://www.amberbit.com/blog/2015/12/22/when-choose-elixir-over-ruby-for-2016-projects&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
    We are mostly happy with Ruby and Rails, but the language, and the framework are facing some serious problems. Some of us do not believe those problems can be resolved, and there is the need for new platform for more reliable, faster and more concurrent applications.
&lt;/blockquote&gt;
...

&lt;blockquote&gt;
    Elixir runs on Erlang VM, and solves some serious problem Ruby has now. It does support actor-model concurrency mechanism. There is no Global Interpreter Lock. It comes with it’s own persistence solutions, handles distributed systems way better than Ruby, provides way to run programs on Windows servers and allows bundling compiled programs into releases. It runs fast, way faster than Ruby code. Does not choke on a hundred concurrent websocket connections. At some point we were missing all of those features when working with Ruby. We can solve those problems now, with Elixir.
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
    The web changed a lot since the year 2006.

    Users’ expectations about web apps changed too. People don’t want to wait or reload page to see the effect. They want to see more and more live/instant updates.

    We have been joking about making a “real-time Rails app” template that integrates Faye, share.js and couple of other useful tools into the standard stack. In fact, this is where Rails slowly evolved in the end by introducing ActionCable.

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;When to pick Elixir?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
    &lt;h5&gt;1. High-traffic systems&lt;/h5&gt;

    Elixir applications can respond in microseconds instead. This can be put to great use. You can handle more requests on the same hardware.


    &lt;h5&gt;2. Systems that do stuff asynchronously&lt;/h5&gt;

      You can design all sorts of asynchronous systems easier in Elixir. Your developers will have to write less code. They will re-use existing patterns and libraries rather than trying to re-invent the wheel.

    &lt;h5&gt;3. Distributed / clustered systems&lt;/h5&gt;

      Erlang and Elixir rely on message passing rather than function calls and sharing state. This makes it perfect for building systems, that are decentralized and fault tolerant.

    &lt;h5&gt;4. High-availability systems with true zero-downtime&lt;/h5&gt;
      Elixir can help you maintain 100% up-time, while still delivering updates to the production system.

    &lt;h5&gt;5. Server-side push and real-time applications&lt;/h5&gt;
      We do know, that Phoenix channels do scale really nicely already.

    &lt;h5&gt;6. Large applications&lt;/h5&gt;

      If the code base of your application is expected to be large, go with Elixir without further thinking. Elixir has a built-in tools, such as umbrella projects that allow you to split the code base into chunks. You can do similar thing with Ruby’s gems, but there is fundamental difference in philosophy behind.
      I found maintaining the large code bases one of the greatest challenges. Developers do appreciate a system that facilitates tools making it easier from day 1.

    &lt;h5&gt;7. When you need smart, experienced developers&lt;/h5&gt;
      Your stack of choice can be a filter for the developers you are hiring. I am observing experienced developers migrating from Ruby to Elixir or Clojure these days.
      There is way less Elixir developers out there, but if they took their time to learn new stack, that’s a good sign of their skills.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;akita&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;fabio-akita-the-obligatory-why-elixir-personal-take-2015-12-http-www-akitaonrails-com-2015-12-01-the-obligatory-why-elixir-personal-take:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Fabio Akita - The Obligatory &amp;ldquo;Why Elixir?&amp;rdquo; Personal Take (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;) - &lt;a href=&#34;http://www.akitaonrails.com/2015/12/01/the-obligatory-why-elixir-personal-take&#34;&gt;http://www.akitaonrails.com/2015/12/01/the-obligatory-why-elixir-personal-take&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;It is a long article with many nuanced details, here are only the Elixir-relevant parts&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;

      &#34;Functional&#34; Concepts that Really Matter
        &lt;h6&gt;Immutability and Opaque Message Passing are VERY important&lt;/h6&gt;
        &lt;h6&gt;Coroutines and Schedulers&lt;/h6&gt;
        &lt;h6&gt;Static vs Dynamic Typing is still controversial&lt;/h6&gt;
        &lt;h6&gt;Fault Tolerance: Don&#39;t fear your code&lt;/h6&gt;
      &lt;hr&gt;
      Erlang has everything, as Joe Armstrong envisioned a fault tolerant system to be.


      &lt;p&gt;

      &lt;strong&gt;Elixir is the missing piece, the Philosopher&#39;s Stone&lt;/strong&gt; if you will, that can unlock all the 30 years of refinements, maturity, industry battle tested technologies in large scales, to the average programmer.
      &lt;/p&gt;

      &lt;p&gt;
      It brings many modern construct such as making macros easier in order to allow for Domain Specific Languages, having testable comments in your code, adding a more modern standard library that is easily recognizable from a Ruby or Clojure point of view, polymorphism through Protocols, and so on.
      &lt;/p&gt;
      &lt;p&gt;
      Erlang is a whole system, it has its own scheduling system, it controls living, breathing processes that each has its own garbage collector, it controls system signal trapping and so on. It was designed to be a full server.
      &lt;/p&gt;
      &lt;p&gt;
      Also because it prioritizes correctness, rigidly isolated processes communicating just by opaque messages, immutable and non-shared states, it means that Erlang is not suited to hard data science processing.
      &lt;/p&gt;
      &lt;br&gt;
      Erlang is good for distributed systems, with high concurrency of opaque message exchange and proxing. The exact scenario where the Web is. Web Applications heavy load of throughput that need real time chats and notifications, heavy and time consuming payment transactions, gathering of data from many sources in order to reduce them to consumable HTML or JSON responses.
      &lt;br&gt;
      &lt;hr&gt;
      Now we can have the comfort of a real modern language with hints of Ruby and Clojure, without the complexities of strong typing but with the security of its built-in Fault Tolerance constructions in order to deliver highly reliable, highly scalable, modern Web applications.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;clark-kampfe&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;clark-kampfe-elixir-is-not-ruby-2015-11-https-zeroclarkthirty-com-2015-11-01-elixir-is-not-ruby-html:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Clark Kampfe - Elixir is not Ruby (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;https://zeroclarkthirty.com/2015-11-01-elixir-is-not-ruby.html&#34;&gt;https://zeroclarkthirty.com/2015-11-01-elixir-is-not-ruby.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  In Ruby, one moves through a monolithic call stack, manipulating objects.


  Elixir (and every other language on the BEAM virutal machine) is built around processes.
  The defining features of a process are its memory independence and the asynchronicity of its execution.
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
  To program Elixir is to program in a functional style.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the function as the primary abstraction&lt;/li&gt;
&lt;li&gt;immutability of data&lt;/li&gt;
&lt;li&gt;referential transparency&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;&lt;/p&gt;

&lt;p&gt;The idiom in Ruby is overwhelmingly to mutate state.
  The amount of Ruby code I have seen that is concurrent at the application level is vanishingly small, and given the prominence of the above patterns and others, it isn&amp;rsquo;t difficult to see why.&lt;/p&gt;

&lt;p&gt;Ruby and Elixir encourage behaviors as different as prank calls and ballet.
&lt;/blockquote&gt;
&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
    Both languages place value on what is known in the Ruby community as &#34;programmer happiness&#34;.


    As an Erlang, Elixir and its runtime come from a family whose main concerns are reliability, consistency, and concurrency. It is a community that is obsessed with failure: understanding it, preparing for it, and embracing it. Things fall apart.


    Ruby is hugely popular among solo developers, consultancies, startups and beginners. That is, programmers who are generally concerned more with time-to-market and short-term ROI rather than maintenance.
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
    Elixir is poised to walk off with Ruby&amp;rsquo;s bacon, as it fuses these two mentalities: systems that run for years should be as enjoyable to build as a NetHack clone.
&lt;/blockquote&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;john-orford&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;john-orford-10-reasons-to-use-elixir-in-finance-2015-11-http-blog-johnorford-com-2015-11-01-x-reasons-to-use-elixir-in-finance:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;John Orford - 10 Reasons To Use Elixir In Finance (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://blog.johnorford.com/2015/11/01/x-reasons-to-use-elixir-in-finance/&#34;&gt;http://blog.johnorford.com/2015/11/01/x-reasons-to-use-elixir-in-finance/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;1. Syntax&lt;/h5&gt;

      Ruby looks and feels right. Elixir has the same mindset and looks beautiful.
    &lt;h5&gt;2. Semantics&lt;/h5&gt;
       Elixir&#39;s compiles down into the Erlang virtual machine (EVM)
    &lt;h5&gt;3. Massively Parallel&lt;/h5&gt;
      Want to keep track of a large portfolio of stocks? Easy. Want to keep track of the whole market? No sweat.
    &lt;h5&gt;4. Stable&lt;/h5&gt;
      How? Massive parallelism also results in massive redundancy.
    &lt;h5&gt;5. Distributed&lt;/h5&gt;
      Elixir has distributed computing included out of the box.
    &lt;h5&gt;6. Modern&lt;/h5&gt;
      Elixir comes without all the cruft but with all the experience.
    &lt;h5&gt;7. Efficiency&lt;/h5&gt;
      Why? Because utilising multicore systems is surprisingly tricky for C# or Java developers.
    &lt;h5&gt;8. Future Proof&lt;/h5&gt;
      Rather than re-engineering, Elixir gives us a get out.
    &lt;h5&gt;9. Pipes&lt;/h5&gt;
      Its pipe operator |&gt; is simple and extremely appealing.
    &lt;h5&gt;10. Young&lt;/h5&gt;
      On the one hand this means that there are not many quantitative libraries - but it also means you can get in on the ground floor.

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;jerel-unruh&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;jerel-unruh-why-i-m-excited-about-elixir-and-phoenix-2015-11-http-jerel-co-blog-2015-11-why-im-excited-about-elixir-and-phoenix:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Jerel Unruh - Why I&amp;rsquo;m excited about Elixir and Phoenix (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://jerel.co/blog/2015/11/why-im-excited-about-elixir-and-phoenix&#34;&gt;http://jerel.co/blog/2015/11/why-im-excited-about-elixir-and-phoenix&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jerel Unruh is a Python developer learning Elixir. He is excited about realtime possibilities in Phoenix and the functional approach to structure your applications with Plugs and data transformations of your &lt;strong&gt;conn&lt;/strong&gt;-datastructure.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Phoenix is functional. Every backend framework I&#39;d used before was object oriented and I assumed functional programming, the GNU project, and Gentoo had a lot in common. It&#39;s turning out to be quite user friendly and really nice...
  &lt;/p&gt;
  &lt;p&gt;
  As mentioned in the example above you have data (a connection) that you perform transformations on until it reaches the state you want. In Phoenix these steps of transformations are called Plugs which are Elixir modules with functions init (compile time) and call (run time) defined. Plugs are not entirely unlike middleware in other frameworks but in Phoenix almost everything is a plug. CSRF protection in the framework? A plug. Body parsing in the framework? A plug. Authentication in your code? Write a plug. Permissions? Write a plug. Do you want different permissions in a couple controllers? Include a plug in those controllers. If you don&#39;t like something that the framework does then swap out that plug. You starting to get the picture? :) And if at any point you wonder what the state of your app is you can IO.inspect(conn) and everything is there, as data.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;david-cristofaro&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;david-cristofaro-drinking-the-elixir-2015-11-http-dtcristo-com-drinking-the-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;David Cristofaro - DRINKING THE ELIXIR (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://dtcristo.com/drinking-the-elixir&#34;&gt;http://dtcristo.com/drinking-the-elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;Elixir:&lt;/h5&gt;
  &lt;ul&gt;
    &lt;li&gt;A natural syntax inspired by Ruby.&lt;/li&gt;
    &lt;li&gt;Lazy evaluation from Haskell.&lt;/li&gt;
    &lt;li&gt;Protocols, macros and pipelines from Clojure.&lt;/li&gt;
    &lt;li&gt;Functional programming&lt;/li&gt;
    &lt;li&gt;Extensibility&lt;/li&gt;
    &lt;li&gt;Modern tooling&lt;/li&gt;
    &lt;li&gt;Full compatibility with Erlang&lt;/li&gt;
  &lt;/ul&gt;

  The result of all of this is a truly modern, practical and performant language on a platform capable of supporting even the most ambitious projects.

  &lt;h5&gt;Phoenix rises&lt;/h5&gt;

    &lt;p&gt;
    Phoenix is built for speed. Response times are measured in the microsecond. With Phoenix, don’t have to sacrifice performance for the sake of productivity. You can have your cake and eat it.
    &lt;/p&gt;
    &lt;p&gt;
    Phoenix is designed with real-time applications in mind, taking full advantage of Elixir’s concurrency model.
    With the help of Phoenix, Elixir is set to be the go-to language for the web and poised to kickstart a real-time web revolution.
    &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;span id=&#34;rob-conery&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;rob-conery-hello-elixir-wow-2015-09-http-rob-conery-io-2015-09-03-hello-elixir-wow:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Rob Conery - Hello Elixir. Wow. (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) - &lt;a href=&#34;http://rob.conery.io/2015/09/03/hello-elixir-wow/&#34;&gt;http://rob.conery.io/2015/09/03/hello-elixir-wow/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  ....

  &lt;h5&gt;Why Is Elixir Exciting?&lt;/h5&gt;
  &lt;p&gt;
  Elixir is exciting to me because it’s fast, fast, my god it’s fast and has many of the nice facilities that Ruby does – with the power of Erlang behind it.
  &lt;/p&gt;
  &lt;p&gt;

  I like this.
  &lt;/p&gt;

  ...

  &lt;h5&gt;Why I Put Wow In The Title&lt;/h5&gt;
  &lt;p&gt;
  Elixir is intimidating to me. I suck as a programmer and really, I’m kind of a hack. But in about 3 hours I was able to take what I read in a book, connect to a database without a framework and execute something in a rather elegant way.
  &lt;/p&gt;
  &lt;p&gt;
  Wow. This made me quite happy today. We’ll see about tomorrow.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;chris-nelson&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;team-at-gaslight-4-reasons-we-re-having-fun-programming-elixir-2015-09-by-chris-nelson-https-teamgaslight-com-blog-4-reasons-were-having-fun-programming-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Team at Gaslight - 4 Reasons We&amp;rsquo;re Having Fun Programming Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) by Chris Nelson - &lt;a href=&#34;https://teamgaslight.com/blog/4-reasons-were-having-fun-programming-elixir&#34;&gt;https://teamgaslight.com/blog/4-reasons-were-having-fun-programming-elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;The Community Is Amazing&lt;/h5&gt;
    It’s not just Dave Thomas; it’s also the amazing progress of the whole Elixir community. In the last year, the amount of progress has been really impressive.


  &lt;h5&gt;Not Object Oriented, Process Oriented&lt;/h5&gt;
    I get to reap some of the key benefits of functional programming on top a runtime that has processes as core level of abstraction.

    &lt;p&gt;
    Processes are light weight, maintain per process state, and communicate purely by passing messages. In a lot of ways, they arguably embody the original vision that the inventors of object oriented had in mind.
    &lt;/p&gt;
    &lt;p&gt;
    The other great thing about Elixir (really Erlang) processes is that they finally bring a viable answer to many of the challenges of decomposing a large system into services (microservices architecture).
    &lt;/p&gt;
    &lt;p&gt;
    Because OTP has well thought out solutions, it’s possible to break off pieces of a system into services and distribute them with much less ceremony and effort.
    &lt;/p&gt;

  &lt;h5&gt;The PEEP stack&lt;/h5&gt;
    &lt;p&gt;
    stands for Phoenix, Elixir, Ember, and PostgresSQL.

    It’s very familiar if you’re coming to it with Rails experience, and this is by design

    Phoenix feels just as productive as Rails to jump into, but there a few reasons it feels even better for building “ambitious web applications”
    &lt;/p&gt;

    &lt;p&gt;
    Building RESTful JSON APIs feels really natural, and even simpler than it does in Rails.
    &lt;/p&gt;

  &lt;h5&gt;It’s Insanely Fast&lt;/h5&gt;
    We’ve frankly struggled to get the performance out of Ruby we would like and having to fight with this less would make us very happy.
    &lt;p&gt;
    And lest you think “Does Telco experience translate to web apps?” it’s worth checking out this about the WhatsApp engineering team from a few years back.
    &lt;/p&gt;

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;luc-fueston&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;luc-fueston-the-real-reason-i-like-elixir-2015-09-http-blog-maketogether-com-the-real-reason-i-like-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Luc Fueston - The (Real) Reason I Like Elixir  (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) - &lt;a href=&#34;http://blog.maketogether.com/the-real-reason-i-like-elixir/&#34;&gt;http://blog.maketogether.com/the-real-reason-i-like-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Luc Fueston likes the Lispy-ness of Elixir and thinks that &amp;ldquo;Macros are the Hammer that Jose Used to Nail It&amp;rdquo;.&lt;/p&gt;

&lt;blockquote&gt;
  The real reason, the guilty pleasure reason that I like Elixir so much is because of Lisp-style macros. They&#39;re such a healthy way to do &#39;meta&#39;-programming: by making it go away at compile-time.

Like many programmers, I love Lisp but don&#39;t use it day-to-day, and I miss the ways Lisp lets me think about a problem.

I don&#39;t simply like Elixir because it&#39;s a good-enough substitute for Lisp. But I&#39;ve been following and experimenting with macros outside of Lisp for a while, and macros are one of the reasons for Elixir&#39;s success.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;luke-imhoff&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;luke-imhoff-why-elixir-2015-07-https-kronicdeth-github-io-why-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Luke Imhoff - WHY ELIXIR? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;) - &lt;a href=&#34;https://kronicdeth.github.io/why-elixir/&#34;&gt;https://kronicdeth.github.io/why-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Functional Programming:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mathematical functions&lt;/li&gt;
&lt;li&gt;Avoids changing state&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modules + Functions&lt;/li&gt;
&lt;li&gt;Pattern Matching + Guards&lt;/li&gt;
&lt;li&gt;Recursion&lt;/li&gt;
&lt;li&gt;Concurrency&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tooling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mix&lt;/li&gt;
&lt;li&gt;ExUnit&lt;/li&gt;
&lt;li&gt;ExDoc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Macros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Capture code&lt;/li&gt;
&lt;li&gt;Compile data into code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Protocols + Pipes + Process Scaling&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;aaron-lebo&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;aaron-lebo-the-unix-philosophy-and-elixir-as-an-alternative-to-go-2015-06-http-lebo-io-2015-06-22-the-unix-philosophy-and-elixir-as-an-alternative-to-go-html:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Aaron Lebo - The UNIX Philosophy and Elixir as an Alternative to Go (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) - &lt;a href=&#34;http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html&#34;&gt;http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Elixir is a very light Ruby-ish layer of syntax that compiles down to run on BEAM, the Erlang VM.&lt;/h5&gt;

    &lt;br&gt;
    &lt;p&gt;
    What I do want to touch on are the qualities of Elixir itself. Do you want a modern language? Elixir is functional, immutable, and supports pattern matching, which is like a case or if statement on steroids, only that explanation doesn&#39;t begin to touch how much it impacts your entire manner of coding. It also supports macros which means that the core language can remain small but users can extend the syntax to support patterns the designer never dreamed of. As I said before, it does this with a Ruby-ish syntax.
    &lt;/p&gt;
    &lt;p&gt;
    Despite the fact that it is a very modern language, it is quite small.
    You can read through the language guide in a few hours and have a pretty good grasp on the core concepts
    This also leads to much quicker mastery. Use 10 constructs 100 times each and you&#39;ll get them intuitively much faster than if you use 100 constructs 10 times each.
    &lt;/p&gt;
    &lt;hr&gt;
    Elixir brings so many features which will both make you grow as a programmer and will help your programs to grow elegantly in the future.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;jan-dudulski&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;codetunes-we-all-are-going-to-meet-in-the-elixir-world-2015-06-by-jan-dudulski-http-codetunes-com-2015-we-all-are-going-to-meet-in-the-elixir-world:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Codetunes - We all are going to meet in the Elixir world (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) by Jan Dudulski - &lt;a href=&#34;http://codetunes.com/2015/we-all-are-going-to-meet-in-the-elixir-world/&#34;&gt;http://codetunes.com/2015/we-all-are-going-to-meet-in-the-elixir-world/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
  &lt;p&gt;
  I attended ElixirConf.eu in April. About 95% of attendees came from the Ruby world. I spoke with many of them and each were speaking the same way - they’re looking for something better. They’re tired of Rails&amp;rsquo; monolithic design, struggling with thread safety and heavy processes.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
  And Elixir seems to be a perfect solution for us, tired Rubists. Beautiful syntax, functional paradigm, successful Erlang VM, incredible performance, dozens of very smart people behind it - this is just the tip of the iceberg and the reason why a lot of devs are so excited already.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
    During the conference I heard a story from guys who were able to stop worrying about cache completely - Elixir was so fast! About a painful - at first sight - migration because of missing tools, but also about the ease of building support for them or replacing them with a better toolset. I saw real enjoyment about the possibilities and pleasure of hacking around - e.g. playing with lego robots. I enjoyed every talk and, for me, it was the most inspiring conference I’ve ever attended.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
    You will love the fail fast strategy. You will love pattern matching. You will love pipe operator. You will love Ecto and Phoenix. You will love compilator and no more runtime errors. You will love Erlang Processes and how easy it is to just run something in the background.
  &lt;/p&gt;
  &lt;p&gt;
    And you will never want to go back.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;lau-taarnskov&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;lau-taarnskov-elixir-the-next-big-language-for-the-web-2015-04-http-www-creativedeletion-com-2015-04-19-elixir-next-language-html:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Lau Taarnskov - Elixir - The next big language for the web (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;) - &lt;a href=&#34;http://www.creativedeletion.com/2015/04/19/elixir_next_language.html&#34;&gt;http://www.creativedeletion.com/2015/04/19/elixir_next_language.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;

    &lt;h5&gt;From obscurity to the default choice&lt;/h5&gt;
      Rails took Ruby out of obscurity and some years later even many non-programmers had heard about this web framework.
      It was very interesting to see how quickly Rails went from being used by a handful of people to being the “it-framework” and the default choice for startups that needed web based software.

    &lt;h5&gt;Elixir&lt;/h5&gt;
      Elixir has its own package management system, macros, an easy to use build tool and unicode handling.
      Elixir is a language that runs on the Erlang VM.
      So it has all of the benefits of the mature, battle proven system and you can use the existing Erlang libraries with no performance penalty.


    &lt;h5&gt;Immutability and functional programming&lt;/h5&gt;
       Functional programming and immutability helps to clarify things and makes it easier to reason about code.

    &lt;h5&gt;Concurrency&lt;/h5&gt;
      The trend in hardware is more and more CPU cores.
      Doing concurrency in Erlang or Elixir versus other languages is a bit like doing branches in Git vs Subversion
      In Elixir it is very easy to create a new process and it performs very well

    &lt;h5&gt;Web framework&lt;/h5&gt;
      Phoenix is the most popular web framework for Elixir right now.
      One of the most exciting features is the real time capabilities with channels between javascript on the client and Elixir on any of the servers in the cluster.
      Efficiency and speed are important for the end user experience, and also means less waste of energy and money on servers.

    &lt;h5&gt;Programmer happiness and beautiful code&lt;/h5&gt;
      With Elixir I do not feel like I trade any joy or speed of development for the performance, reliability and concurrency benefits of the Erlang VM. Elixir provides all of the Erlang benefits such as performance and reliability without giving up the productivity benefits of Ruby.

    &lt;h5&gt;Déjà vu&lt;/h5&gt;
      Like with Ruby 12 years ago, once again I feel that this new platform is so much better than the other solutions.

      I think it is likely that in a few years Elixir instead will be the go-to language for new web projects.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;josh-smith&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;josh-smith-functional-parallel-programming-in-elixir-2015-03-http-ijoshsmith-com-2015-03-14-functional-parallel-programming-in-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Josh Smith - Functional parallel programming in Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;) - &lt;a href=&#34;http://ijoshsmith.com/2015/03/14/functional-parallel-programming-in-elixir/&#34;&gt;http://ijoshsmith.com/2015/03/14/functional-parallel-programming-in-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;Why Elixir?&lt;/h5&gt;

  &lt;p&gt;
  Over the past few months I studied various functional programming languages, as well as the concurrency and parallel programming models their practitioners espouse.
  &lt;/p&gt;
  &lt;p&gt;
  While certainly seeing value in each language I studied, only Elixir jumped out at me as elegant and expressive yet simple. It is a so-called impure functional language, meaning that it is built to support a functional programming style but also allows for symbols that can change value
  &lt;/p&gt;

  &lt;p&gt;
  Elixir is a modern language that enables today’s mainstream developers to harness the highly concurrent, fault-tolerant, distributed, bulletproof Erlang virtual machine that undergirds much of the telecommunication infrastructure on which our society depends.
  &lt;/p&gt;

  &lt;p&gt;
  After a few days of writing Elixir code, I was impressed. Once I saw firsthand how Elixir and the Erlang VM simplify multi-core computing, I was sold. I don’t expect to write Elixir code for a living any time soon, if ever, but the lessons I learn from the language and platform can be adopted in my daily software development practices. I wrote this article to share those lessons with others.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;ken-mazaika&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;ken-mazaika-why-i-m-betting-on-elixir-2015-01-https-medium-com-kenmazaika-why-im-betting-on-elixir-7c8f847b58:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Ken Mazaika - Why I’m betting on Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;) - &lt;a href=&#34;https://medium.com/@kenmazaika/why-im-betting-on-elixir-7c8f847b58&#34;&gt;https://medium.com/@kenmazaika/why-im-betting-on-elixir-7c8f847b58&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Package Management with Mix&lt;/h5&gt;
      Mix just does its job nicely, stays out of the way, and doesn’t force you to wrangle XML.

    &lt;h5&gt;The Erlang Virtual Machine&lt;/h5&gt;
      emphasis on functional programming that are fault-tolerant and highly scalable.


    &lt;h5&gt;The Phoenix Web Framework&lt;/h5&gt;
      Phoenix is such a Railsy solution you’ll feel like you’re building a Rails app, with the exception being that it runs with Elixir and has all the benefits of Elixir and the Erlang virtual machine.

    &lt;h5&gt;Strong Leadership&lt;/h5&gt;
      In my opinion, the difference between open source and movement, is all around the leadership involved in the project. In short, I believe really smart people need to be putting the work in to improve the software every single day.

      Jose Valim, Chris McCord, and all the members of the Elixir-Lang core team and Phoenix core team have, and continue to put in the work that needs to be done for the Elixir community to thrive.

    &lt;h5&gt;The web is about to under-go a transformational change&lt;/h5&gt;
      The people who will win are going to be the ones who embrace changes in technology. The fact that WebSockets, processes, and concurrency in Phoenix and Elixir are cheap, without sacrificing developer happiness is an absolute game-changer.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;paul-schoenfelder&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;paul-schoenfelder-what-is-elixir-and-why-do-i-care-2014-03-http-bitwalker-org-elixir-erlang-programming-tutorials-2014-03-10-what-is-elixir-and-why-do-i-care:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Paul Schoenfelder - What Is Elixir, and Why Do I Care? (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;) - &lt;a href=&#34;http://bitwalker.org/elixir/erlang/programming/tutorials/2014/03/10/what-is-elixir-and-why-do-i-care/&#34;&gt;http://bitwalker.org/elixir/erlang/programming/tutorials/2014/03/10/what-is-elixir-and-why-do-i-care/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Paul Schoenfelder is productive in C#, Ruby, Python, Javascript, Scala, Clojure, C and C++, but he thinks Elixir provides something, that all the other languages do not&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Elixir’s Elevator Pitch&lt;/h5&gt;
    Elixir is a functional, metaprogrammable language, built for productivity, extensibility, and to take advantage of Erlang’s simple but powerful fault-tolerance and concurrency primitives. It is composed of a simple core language, with syntax that is very reminiscent of Ruby (and no wonder, as its creator José Valim, is a Ruby core committer, and author of many Ruby libraries such as Devise). However, despite the aesthetic similarity to Ruby, the semantics of Elixir are quite different.



    &lt;h5&gt;At a high level, Elixir provides the following features:&lt;/h5&gt;
    &lt;ul&gt;
      &lt;li&gt;Modules&lt;/li&gt;
      &lt;li&gt;First-class functions&lt;/li&gt;
      &lt;li&gt;Pattern matching (amazing)&lt;/li&gt;
      &lt;li&gt;Protocols, which provide polymorphism for your data types.&lt;/li&gt;
      &lt;li&gt;Macros. If you dig in to Elixir’s source code, you will see that the vast majority of the language’s syntax is - actually defined as simple Elixir macros: if, unless, cond, etc. Incredibly powerful feature.&lt;/li&gt;
      &lt;li&gt;Everything is an expression, this makes it easy to compose code without intermediate variables.&lt;/li&gt;
      &lt;li&gt;Immutability&lt;/li&gt;
      &lt;li&gt;Pipes. Instead of defining code inside-out like: &lt;span class=&#34;code&#34;&gt;Date.shift(Date.new({2014, 10, 5}), days: 10)&lt;/span&gt; pipes allow you - to write it as you would say it: &lt;span class=&#34;code&#34;&gt;{2014, 10, 5} |&gt; Date.new |&gt; Date.shift(days: 10)&lt;/span&gt;. Code becomes very easy to read.&lt;/li&gt;
      &lt;li&gt;Dead simple concurrency.&lt;/li&gt;
      &lt;li&gt;Dead simple clustering/distribution.&lt;/li&gt;
      &lt;li&gt;Built-in unit testing&lt;/li&gt;
      &lt;li&gt;First-class documentation (including the ability to test the code examples in your docs!)&lt;/li&gt;
      &lt;li&gt;Excellent build tool (modeled after Leiningen for Clojure, very similar to Rake for Ruby)&lt;/li&gt;
      &lt;li&gt;Excellent documentation and community&lt;/li&gt;
    &lt;/ul&gt;


&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;sasa-juric&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;saša-jurić-why-elixir-2014-01-http-theerlangelist-com-article-why-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Saša Jurić - Why Elixir - (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;) - &lt;a href=&#34;http://theerlangelist.com/article/why_elixir&#34;&gt;http://theerlangelist.com/article/why_elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;strong&gt;Elixir is not Ruby for Erlang.&lt;/strong&gt;

    To me, it is an Erlang-like language with improved code organization capabilities. This definition differs from what you’ll see on the official page, but I think it captures the essence of Elixir, when compared to Erlang.

      &lt;h5&gt;Metaprogramming&lt;/h5&gt;
         It allows us to write concise constructs that seems as if they’re a part of the language. These constructs are in compile-time then transformed into a proper code.

      &lt;h5&gt;Pipeline operator&lt;/h5&gt;
        The pipeline operator works extremely well because the API in Elixir libraries follows the “subject (noun) as the first argument” convention.

      &lt;h5&gt;Polymorphism via protocols&lt;/h5&gt;
        Protocols are the Elixir way of providing something roughly similar to OO interfaces

      &lt;h5&gt;The mix tool&lt;/h5&gt;
        help us manage projects

      &lt;h5&gt;Syntactical changes&lt;/h5&gt;
        support for variable rebinding, optional parentheses, implicit statement endings, nullability, short circuits operators...

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;renderedtext&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;darko-fabijan-learn-elixir-to-stay-young-2014-01-http-renderedtext-com-blog-2014-01-21-learn-elixir-to-stay-young:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Darko Fabijan - Learn Elixir to stay young - (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;) - &lt;a href=&#34;http://renderedtext.com/blog/2014/01/21/learn-elixir-to-stay-young/&#34;&gt;http://renderedtext.com/blog/2014/01/21/learn-elixir-to-stay-young/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;strong&gt;Why Elixir&lt;/strong&gt;
    &lt;p&gt;
      Many say that next programming languages that will matter will be LISP and/or Erlang descendants. Just by simple deduction it seems that Clojure and Elixir are the cool kids that you should hang out with.
    &lt;/p&gt;

    &lt;p&gt;
      It runs on Erlang VM, has a really nice Ruby-like syntax and allows you to write powerful DSLs with macros. The fact that it runs on Erlang VM with its&#39; actor-based architecture means that you can not only transparently run your application across multiple CPU cores without thinking too much, but also run it across multiple machines in almost the same way.
    &lt;/p&gt;

    &lt;p&gt;
      If you ever touched Ruby you know that syntax can really matter and how it just feels nice under your fingers. Well for Elixir I could say the same. And finally macros, originated in LISP, are also available in Elixir because of it’s homoiconicity. Macros give you the power to extend the language as you feel needed and that means that you can turn Elixir in a language specialised for solving your particular problem.
    &lt;/p&gt;
    ...
    &lt;p&gt;
      Elixir is awesome. You will discover and learn many new concepts from computer science that are really powerful but neglected in other languages. Ultimately Elixir will replace Node.js and Ruby in many places and now is a chance to be an Elixir guru even before the waves start rising.
    &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;alexei-sholik&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;alexei-sholik-introducing-elixir-2013-08-http-alexeisholik-com-elixir-talk:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Alexei Sholik - Introducing Elixir (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;08&lt;/sub&gt;) - &lt;a href=&#34;http://alexeisholik.com/elixir-talk/&#34;&gt;http://alexeisholik.com/elixir-talk/&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&#34;why-elixir:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Why Elixir?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;No repetitive boilerplate&lt;/li&gt;
&lt;li&gt;Simple APIs&lt;/li&gt;
&lt;li&gt;DSLs&lt;/li&gt;
&lt;li&gt;Practical (code reuse, meta)&lt;/li&gt;
&lt;li&gt;User friendly (syntax; exceptions; REPL)&lt;/li&gt;
&lt;li&gt;Tools (mix, ExUnit, EEx)&lt;/li&gt;
&lt;li&gt;New, consistent stdlib&lt;/li&gt;
&lt;li&gt;Enthusiastic community&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;devin-torres&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;devin-torres-elixir-it-s-not-about-syntax-2013-06-http-devintorr-es-blog-2013-06-11-elixir-its-not-about-syntax:aa1c6d0861f2f92d8b287802740247ae&#34;&gt;Devin Torres - Elixir: It&amp;rsquo;s Not About Syntax (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) - &lt;a href=&#34;http://devintorr.es/blog/2013/06/11/elixir-its-not-about-syntax/&#34;&gt;http://devintorr.es/blog/2013/06/11/elixir-its-not-about-syntax/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
      &lt;h5&gt;Performance&lt;/h5&gt;

        Performance of Elixir code should match or beat the performance of equivalent Erlang code.
        &lt;p&gt;
        Elixir’s powerful metaprogramming capabilities don’t come from e.g. runtime dispatching, but the fantastically powerful compiler. All this magic happens at compilation time, before your code even has to run. And this is the part that may blow your minds: Elixir will beat the performance of Erlang in some cases.
        &lt;/p&gt;


      &lt;h5&gt;Metaprogrammability&lt;/h5&gt;
        &lt;p&gt;
        Elixir is strongly homoiconic.
        It has one of the most powerful macro system I’ve been able to find in among other macro-capable languages I’ve used to date.
        &lt;/p&gt;
        &lt;p&gt;
        Elixir macros are hygienic. This means that variables defined in a macro won’t interfere with variables defined in the local scope when you use the macro. Oh, and guess what? They are optionally unhygienic as well if you’re into that kind of thing.
        &lt;/p&gt;

        Macros shouldn’t be abused.


      &lt;h5&gt;The standard library and runtime&lt;/h5&gt;

        The Elixir standard library aims to dramatically increase the productivity of Elixir developers, while providing the extensibility and features Elixir developers expect from such a metaprogrammable language.

      &lt;h5&gt;Unafraid of change&lt;/h5&gt;

        We have Erlangers, Clojurists, Haskellers, Rubyists, and Pythonistas trying to incorporate useful features into Elixir every day. Elixir isn’t afraid of introducing functionality that improves the lives of Elixir developers, and everything is on the table: new data structures, real Unicode support, anything.

      &lt;h5&gt;Tooling&lt;/h5&gt;

        IEx, Doctests, Mix

      &lt;hr&gt;

      Elixir is the power of it’s tooling, the expressiveness of it’s metaprogrammability, and the expansive feature set of it’s standard library while maintaining complete compatibility with—and heavily leveraging—OTP.
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Chris McCord on Meteorclub</title>
      <link>http://ruby2elixir.github.io/posts/2015/12-25-chris-mccord-on-meteorclub.html</link>
      <pubDate>Fri, 25 Dec 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/12-25-chris-mccord-on-meteorclub.html</guid>
      <description>

&lt;p&gt;Recently I&amp;rsquo;ve listened to Chris McCord explaining Phoenix + Elixir on Meteorclub where he talks about the surprising code base stability for Phoenix.&lt;/p&gt;

&lt;h3 id=&#34;what-are-phoenix-elixir-and-why-should-i-care-meteor-club-podcast-https-simplecast-fm-s-2f11905f:03baf0baf002209b5b8e1c3bdc4fcfc5&#34;&gt;What are Phoenix &amp;amp; Elixir and why should I care? - Meteor Club Podcast - &lt;a href=&#34;https://simplecast.fm/s/2f11905f&#34;&gt;https://simplecast.fm/s/2f11905f&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;from 25:00&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;
The first 2 weeks you&#39;re gonna be like ... &#34;I hate this! This is stupid!&#34; When I got into Elixir I couldn&#39;t do a recursive loop. I was going through the &#34;Programming Elixir&#34; book and I was like... &#34;I can&#39;t program! I have a programing degree and I can&#39;t .... &#34; So it takes a while but then, once it clicks.. Oh my... This is the best thing ever.
&lt;/p&gt;
&lt;p&gt;
And now trying to go back to Ruby or object oriented languages ... It just does not feel right. But it takes a little bit. I think the community has done a great job. Saying that we know there is this frustration gap to be filled so... Like we&#39;re very helpful to newcomers and noob style questions. The more the merrier.
&lt;/p&gt;
...
&lt;p&gt;
We have quite a small core team, there is 5 of us. And Jose Valim is also on the core team. That has been an enormous boost. He probably has half of commits in Phoenix . But still, quite a small core team. We&#39;re actually shocked...
&lt;/p&gt;
&lt;p&gt;
The few issues that we do have.... So we expected with 1.0 that we&#39;ll have a lot more issues to takle. People are using the framework, companies are using it... Not to like, pat us on the back, but it&#39;s been surprisingly stable. Surprisingly few problems have come up.
&lt;/p&gt;
&lt;p&gt;So for me personally it&#39;s like... You buy into &#34;kool-aid&#34;.... You do, there is no reason not to.   It&#39;s unavoidable. The interesting thing for me is like functional programming
&lt;/p&gt;

&lt;p&gt;
Every step building Phoenix is like... The hype has lived up to the reality. (27:00) Every new feature we write like we wrote the Phoenix HTML layer... Jose and I like walking through the code... &#34;Where is all the code? &#34;
&lt;/p&gt;

&lt;p&gt;
It was shockingly small amount of code and we have a lot fewer issues than we expected.
I think there are 5 open issues or 6 open pull issues on Phoenix right now.
&lt;/p&gt;


&lt;p&gt;
And people are using it!
&lt;/p&gt;
&lt;p&gt;
So far it&#39;s been a good ride!
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So&amp;hellip; This is really one of the most compelling reasons for me to use Elixir: if you got your abstractions right, the code that you write is suprisingly stable and maintainable. It&amp;rsquo;s hard to explain with words, you have really to experience this by trying it youself.&lt;/p&gt;

&lt;p&gt;Maybe this will give you just enough nudge to read the sourcecode for Phoenix and play with it.&lt;/p&gt;

&lt;p&gt;Have a nice day!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Even Bother to Rewrite Your Rails Application in Elixir</title>
      <link>http://ruby2elixir.github.io/posts/2015/11-25-why-even-bother-to-rewrite-your-rails-application-in-elixir.html</link>
      <pubDate>Wed, 25 Nov 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/11-25-why-even-bother-to-rewrite-your-rails-application-in-elixir.html</guid>
      <description>&lt;p&gt;Hey there, I believe that our future as web software development is going to change soon.
There is a lot of ways to write software and I have chosen to write web applications. &lt;strong&gt;My goal is to build my own SaaS business soon and be responsible for it&lt;/strong&gt;. When you have that perspective you treat any superficial level of &lt;strong&gt;complexity as unacceptable&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This is the reason why in 2007 I have learned Ruby and why I wrote my first web applications in Rails. I had to be able to &lt;strong&gt;maintain my applications in the long run&lt;/strong&gt;. To peek behind the curtain, I chose a &lt;strong&gt;path of apprenticeship&lt;/strong&gt; and joined a then young startup named &lt;strong&gt;DaWanda and watched it grow from 12 people to 200 people&lt;/strong&gt;. It grew from a single largish Rails app deployed on 5 dedicated server to a beast of multiple apps with &lt;strong&gt;slow test suites&lt;/strong&gt; and &lt;strong&gt;plenty of moving parts&lt;/strong&gt;&amp;hellip; To keep the thing running required quite a lot mental effort and it was a dedicated job in itself. You build &lt;strong&gt;abstractions upon abstractions and depend on a hefty amount of third-party libraries just to keep your application alive&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Timeouts, network partitions, lots of small inconsistencies, memory leaks, hanging processes&lt;/strong&gt; : it all becomes your daily business.&lt;/p&gt;

&lt;p&gt;This is not how I envision my own applications in the future&amp;hellip; They should &lt;strong&gt;fit into my little brain&lt;/strong&gt;. They should grow with grace, be maintainable, resource-efficient, provide just the right abstractions to help me in the beginning, but &lt;strong&gt;get out of the way when I&amp;rsquo;m going against recommendations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Playing with different languages showed some promise, but the &lt;strong&gt;lost productivity compared to Rails was hard to justify&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;That is until Elixir + Phoenix happened.&lt;/p&gt;

&lt;p&gt;It was not an instant insight, rather a slow process. You discover the author&amp;rsquo;s intents while solving small problems, you gather all the small bits of wisdom in discussions, you always ask the same question: &amp;ldquo;Where is the catch? It this too good to be true?&amp;rdquo;. So, I&amp;rsquo;m a &lt;strong&gt;careful &amp;ldquo;buyer&amp;rdquo; into new technogy&lt;/strong&gt;, there is just too much &amp;ldquo;innovation&amp;rdquo; happening right now.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m &lt;strong&gt;in this game for a long run&lt;/strong&gt;, so &lt;strong&gt;cutting corners in the beginning only to slow down in the future&lt;/strong&gt; is not an option.&lt;/p&gt;

&lt;p&gt;I also don&amp;rsquo;t want to buy into the &amp;ldquo;microservices&amp;rdquo; craziness that is all the range right now, you need many teams to compensate the trade-offs of that approach.&lt;/p&gt;

&lt;p&gt;I want a technology that will help me to ship products with certain guarantees.&lt;/p&gt;

&lt;p&gt;It should:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;be easily composable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scale vertically&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scale horizontally&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;be reliable&lt;/li&gt;
&lt;li&gt;be introspectable&lt;/li&gt;
&lt;li&gt;have great tooling&lt;/li&gt;
&lt;li&gt;provide &lt;strong&gt;productivity during development&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;provide &lt;strong&gt;productivity during production&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I am absolutely sure that &lt;strong&gt;Elixir/OTP&lt;/strong&gt; is currently &lt;strong&gt;THE ONLY LANGUAGE / PLATFORM&lt;/strong&gt; that gives you all that in a nice package.&lt;/p&gt;

&lt;p&gt;But it is hard to convince fellow developers when they see their cozy &amp;ldquo;Ruby&amp;rdquo; world threatened. &amp;ldquo;Why?&amp;rdquo; they say. &amp;ldquo;I&amp;rsquo;m totally fine with Rails. It solves my problems and that&amp;rsquo;s enough.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well&amp;hellip; The world is evolving. The applications of future demand to be more reliable, more realtime, much faster, cope with much more traffic from many more devices than today.&lt;/p&gt;

&lt;p&gt;Rails offers no solution for distributed systems - embrace the &lt;strong&gt;majestic monolith&lt;/strong&gt;. No solution for concurrent systems - &lt;strong&gt;background jobs as a poor abstraction&lt;/strong&gt; e.g Sidekiq. No reliable solution for realtime systems - &lt;strong&gt;ActionCable is a hack&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;And it is not Rails&amp;rsquo; fault, really. Ruby as a Virtual Machine helps you in the beginning, but &lt;strong&gt;hinders you when your application matures&lt;/strong&gt;. When you outgrow that single Rails app. When it&amp;rsquo;s time to break it apart. Be prepared for the &lt;strong&gt;zoo of technologies&lt;/strong&gt; just to keep it somehow alive. And let me tell you one thing: you will probably never feel like you control the system.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s ok, you will earn money with it. And Rails is not dying, as some might say.&lt;/p&gt;

&lt;p&gt;It just got&amp;hellip; Well&amp;hellip; Old.&lt;/p&gt;

&lt;p&gt;Not appropriate for the future we are about to face.&lt;/p&gt;

&lt;p&gt;Ambitious, demanding apps require modern tooling and new approaches. The world is realtime.&lt;/p&gt;

&lt;p&gt;It is &lt;strong&gt;hard to scale Rails apps and keep quality up&lt;/strong&gt;. Usually you&amp;rsquo;ll end up &lt;strong&gt;hiding behind caching&lt;/strong&gt;, like MemCached, Redis, Varnish, Fastly&amp;hellip; That&amp;rsquo;s it. And you&amp;rsquo;ll spent a lot of time &lt;strong&gt;ironing all the bugs that occur only in production&lt;/strong&gt; and you will have a lot of hard time doing that. You&amp;rsquo;ll have to employ &lt;strong&gt;large teams of developers later in the game to overcome limitation of Rails&lt;/strong&gt;. And maybe you&amp;rsquo;ll fine with that, because that is the current state of affairs in the industry. Many decide to &lt;strong&gt;jump ship and build microservice architectures&lt;/strong&gt;. But there is &lt;strong&gt;no free lunch&lt;/strong&gt; here, you&amp;rsquo;ll still need multiple teams of developers responsible for them. And it certainly requires quite &lt;strong&gt;a lot of unlearning and patience to become even slightly productive with that approach&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Elixir + Phoenix combo gives you both: &lt;strong&gt;write as monolithic app now, easily split up into several applications later&lt;/strong&gt;, use Erlang VM as &lt;strong&gt;operating system to write your application&lt;/strong&gt;. Currently there is &lt;strong&gt;no alternative for that approach&lt;/strong&gt; that is more elegant and efficient.&lt;/p&gt;

&lt;p&gt;Watch this space closely, &lt;strong&gt;Elixir is gaining steam with incredible speed&lt;/strong&gt; and will surpass Rails in 2-3 years easily.&lt;/p&gt;

&lt;p&gt;Phoenix is &lt;strong&gt;not a clone of Rails&lt;/strong&gt;, it is the ultimate combination of years of experience with demanding Rails applications combined into a very &lt;strong&gt;robust, simple, extensible and highly performant package&lt;/strong&gt;, standing on shoulders of over 30 years experience building &lt;strong&gt;highly available soft-realtime systems&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;It is very hard to top that.&lt;/p&gt;

&lt;p&gt;Think like a professional and &lt;strong&gt;invest in your future now&lt;/strong&gt;. Go to &lt;a href=&#34;http://elixir-lang.org/learning&#34;&gt;http://elixir-lang.org/learning&lt;/a&gt; and learn Elixir, you wont regret this decision a single minute. I certainly did not!&lt;/p&gt;

&lt;p&gt;Cheers and all the best,
Roman&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>