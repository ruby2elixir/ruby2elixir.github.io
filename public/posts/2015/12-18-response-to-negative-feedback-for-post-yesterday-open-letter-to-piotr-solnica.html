    

    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="RUBY 2 ELIXIR">
		<meta name="description" content="Community-driven initiative to switch from Ruby to Elixir">
		<meta name="generator" content="Hugo 0.15" />
		<title>Response to Negative Feedback for Post Yesterday: Open Letter to Piotr Solnica &middot; Ruby 2 Elixir Blog</title>
		<link rel="shortcut icon" href="http://ruby2elixir.github.io/images/favicon.ico">
		<link rel="stylesheet" href="http://ruby2elixir.github.io/css/style.css">
		<link rel="stylesheet" href="http://ruby2elixir.github.io/css/highlight.css">
		<link href="http://ruby2elixir.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Ruby 2 Elixir Blog" />
	</head>
    <body>
       <nav class="main-nav">
	
	
		<a href='http://ruby2elixir.github.io/'> <span class="arrow">←</span>Home</a>
	

	
		<a href='http://ruby2elixir.github.io/about.html'>About</a>
	

	
</nav>

        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>Response to Negative Feedback for Post Yesterday: Open Letter to Piotr Solnica</h1>
                    <h2 class="headline">December 18, 2015</h2>
                </header>
                <section id="post-body">
                    

<p>EDIT:


<figure >
    <img src="http://ruby2elixir.github.io/media/posts/2015/tweet_1_josevalim.png" />
    <figcaption>
        
    </figcaption>
</figure>



<figure >
    <img src="http://ruby2elixir.github.io/media/posts/2015/tweet_2_josevalim.png" />
    <figcaption>
        
    </figcaption>
</figure>
</p>

<p>Apologies to anybody offended by the following post and especially to Piotr Solnic. I feel his energy and creativity would have a more productive foundation if he chose to express his code in Elixir, but it was certainly not my intention to intimidate him. If there is public interest to take this post down, I will.</p>

<p>Sorry for confusion!</p>

<hr>

<p>Original post:</p>

<p>My blogpost from yesterday <a href="http://ruby2elixir.github.io/posts/2015/12-17-elixir-vs-ruby---code-quality.html">Elixir vs Ruby - Code Quality</a> seems to have upset quite some people due to its unscientific way of comparing 2 programming language code bases. Most of the criticism is right, number of open issues and outstanding pull request alone do not make a convincing argument&hellip; But it got me some valuable ideas, how to convey the real facts, that I personally find fascinating and intriguing&hellip;</p>

<p>The real metric I wanted to underline is the speed of issue resolving. And the factors that play into it, like ease of bug reproduction, the speed of test suites and conceptual code flexibility.</p>

<p>I understood this while writing a response to Piotr Solnic (<a href="http://solnic.eu/">http://solnic.eu/</a>).</p>

<p>While speed of issue resolving as metric is not analysed here further, I&rsquo;d like to include my response to the critique of yesterday&rsquo;s blog post.</p>

<hr>

<p><quote>
originally posted on reddit/r/ruby
  <a href="https://www.reddit.com/r/ruby/comments/3x7m4h/ruby_vs_elixir_code_quality_on_github/">https://www.reddit.com/r/ruby/comments/3x7m4h/ruby_vs_elixir_code_quality_on_github/</a>
</quote></p>

<p>Yes, the title is misleading, it should be more like: <strong>the speed of issue resolving in Ruby vs Elixir core languages</strong>. By proxy this metric says something about the quality of code, but it is not directly &ldquo;quality of code&rdquo;. It&rsquo;s hard to give precise metrics for &ldquo;quality&rdquo;&hellip; You start to understand quality when you interact with the object in question.</p>

<p>First commit to Elixir was in <sup>2011</sup>&frasl;<sub>01</sub> (<a href="https://github.com/elixir-lang/elixir/commits/master?page=289">https://github.com/elixir-lang/elixir/commits/master?page=289</a>), so it is widely considered a &ldquo;young&rdquo; language.</p>

<p>Elixir while being seemingly a &ldquo;young&rdquo; language, is getting all the benefits of 30 years old Erlang VM and the not many but very solid libraries in the Erlang ecosystem. That is a much more solid foundation than Ruby VM can ever get.</p>

<p>Most of Elixir is implemented in Elixir, making contribution quite easy. Due to its functional nature you as developer are encouraged to structure your code in side-effect free functions transforming immutable datastructures. While being unfamiliar to most OOP programmers, this leads to more explicit and robust code.</p>

<p>The test suite for the <strong>whole elixir language</strong> passes in <strong>3 <sup>1</sup>&frasl;<sub>2</sub> minutes</strong> on travis-ci
  - <a href="https://travis-ci.org/elixir-lang/elixir/builds/97507754">https://travis-ci.org/elixir-lang/elixir/builds/97507754</a>.</p>

<p>The <strong>core takes only 42.3 seconds</strong> (time you need to run tests locally, without fresh installation):
  - <a href="https://travis-ci.org/elixir-lang/elixir/builds/97507754#L383">https://travis-ci.org/elixir-lang/elixir/builds/97507754#L383</a></p>

<p>The test suite for <strong>phoenix</strong> passes in <strong>1 min 38</strong> sec on travis:
  <a href="https://travis-ci.org/phoenixframework/phoenix/builds/97573360">https://travis-ci.org/phoenixframework/phoenix/builds/97573360</a></p>

<p>The actual suite for the <strong>phoenix core</strong> takes only <strong>around 20 sec</strong>:
  <a href="https://travis-ci.org/phoenixframework/phoenix/builds/97573360#L381">https://travis-ci.org/phoenixframework/phoenix/builds/97573360#L381</a></p>

<p>It seems like nobody ever bothered to <strong>compare open source programming languages by the speed of issue resolving</strong>&hellip; I have a strong conviction that <strong>this little metric is a strong indicator for the future success</strong> of that particular language. And surely it is not reflected in the numbers presented in the article yesterday because it would require much more effort to statistically evaluate a meaningful value for each resolved issue on Github. So yeah, that article is probably mostly meaningless for any serious statistical evaluation. But it emphasises something that most developers <strong>neglect to consider</strong> when picking a new language to learn:</p>

<ul>
<li><strong>number of currenly known and unresolved bugs/issues</strong> in a language</li>
<li><strong>how fast</strong> are those issues resolved</li>
</ul>

<p>To take your argument further, one would believe that a young programming language has <strong>by default much less open issues due to its lesser popularity</strong>&hellip;</p>

<p>What about Rust: <a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a> ?</p>

<p>It currently has <strong>2286 open issues and 94 outstanding pull requests</strong>.</p>

<p>First commit is from <sup>2010</sup>&frasl;<sub>06</sub> (<a href="https://github.com/rust-lang/rust/commits/master?page=1395">https://github.com/rust-lang/rust/commits/master?page=1395</a>), only 6 months older than Elixir.</p>

<p>Is Rust more popular? If we consider the number of stars, it is <strong>3x more popular than Elixir</strong>. But the number of open issues is ca. <strong>70x (2286 / 32) higher than for Elixir. What&rsquo;s going on here?</strong></p>

<p>If you check the last build for Rust</p>

<p><a href="https://travis-ci.org/rust-lang/rust/builds/97619789">https://travis-ci.org/rust-lang/rust/builds/97619789</a></p>

<p>it took <strong>51 min 30 sec.</strong></p>

<p>Just imagine the <strong>developer ergonomics</strong>&hellip; You make some changes&hellip; You push to Github&hellip; After nearly <strong>1h waiting comes the response: failed build</strong>. Every attempt to fix the build will cost you ca. 1h of your life&hellip; How <strong>many productive hours</strong> do you think you will have in that kind of environment?</p>

<p>Now contast this with the Elixir test suite. It take much less time to <strong>verify your changes locally</strong> and it is much <strong>more fun to keep the build green on travis</strong>, because the <strong>cost per iteration is intentionally kept very low</strong>. This makes <strong>contribution by community much more likely</strong>*. And the core team has much <strong>more time to close outstanding issues and merge pull requests</strong>. You as developer can be <strong>in &ldquo;flow&rdquo; state more often</strong> because the <strong>feedback loop is so quick</strong>.</p>

<hr>

<h3 id="personal-appeal:d51fd71bc356afea6bfa07cced01a01e">Personal appeal</h3>

<p>Piotr, I have read you blog posts quite often and you come across as quite controversial and forward-thinking person.</p>

<p>If we take that quite recent post of yours:
  <a href="http://solnic.eu/2015/03/04/8-things-i-learned-during-8-years-of-ruby-and-rails.html">http://solnic.eu/2015/03/04/8-things-i-learned-during-8-years-of-ruby-and-rails.html</a></p>

<ul>
<li><p>TDD: is of paramount importance, right? Elixir makes it even easier than Ruby</p></li>

<li><p>World outside of Rails:  maybe also outside Ruby?</p></li>
</ul>

<p>I have tested ALL the Ruby web microframeworks out there&hellip;. They don&rsquo;t help that much, but require much more time investement -&gt; <a href="https://github.com/luislavena/bench-micro/commits/master?page=2">https://github.com/luislavena/bench-micro/commits/master?page=2</a></p>

<ul>
<li><p>Immutability: now we are talking! <strong>Immutability in Ruby</strong> is well&hellip; Awkward. Inefficient. Against the language philosophy. Not fun at all.</p></li>

<li><p>No rules, just guidelines: Right! You should be free to structure your application in a way that is meaningful to you. Sadly most companies are embracing the &ldquo;Rails Way&rdquo; of doing things&hellip; You&rsquo;ll fight always an uphill battle to change it.</p></li>

<li><p>Convenience has a big price: Right, if you&rsquo;re talking about Rails! With Elixir / Phoenix you can keep convenience without making sacrifices in speed and developer productivity, even longterm.</p></li>

<li><p>Mutation testing: This is not needed in Elixir, because all the data is immutable! But you can use QuickCheck for property based testing, see <a href="http://www.erlang-factory.com/sfbay2015/thomas-arts">http://www.erlang-factory.com/sfbay2015/thomas-arts</a></p></li>

<li><p>Ideas behind ORM are a fallacy: RIGHT!</p></li>
</ul>

<blockquote>
<p>&ldquo;I want simple data processing. I want immutable data. When I need to build a UI it should efficiently write changes back to the database when a client sends a request to do so. And that is not an ORM.&rdquo;</p>
</blockquote>

<p>Take a look at Ecto - <a href="https://github.com/elixir-lang/ecto">https://github.com/elixir-lang/ecto</a> + some links here: <a href="https://github.com/mindreframer/getoffrails/blob/master/ecto.md">https://github.com/mindreframer/getoffrails/blob/master/ecto.md</a></p>

<p>You get back simple data-structures. Without magic. Validation happen in changesets.</p>

<p>It that is too much for your taste, try that one:
    <a href="https://github.com/robconery/moebius">https://github.com/robconery/moebius</a> (only for PostgreSQL). Inspired by Sequel by Jeremy Evans. Since you&rsquo;re writing a book about Roda, you&rsquo;ll know him ;)</p>

<hr>

<h3 id="the-point-i-m-trying-to-make-is:d51fd71bc356afea6bfa07cced01a01e">The point I&rsquo;m trying to make is:</h3>

<ul>
<li>Do you think you could fix Ruby to accomodate your wishlist outlined above? How long would it take? Is it possible at all?</li>
</ul>

<p>THIS IS THE SAME QUESTION THAT JOSE VALIM HAD FACED. Then he tried to <strong>bring concepts from Erlang language to Ruby and failed</strong>, unsurprisingly&hellip;
So he chose to <strong>bring the good parts of Ruby to the Erlang VM</strong>. That gave birth to Elixir. Despite being considered a &ldquo;young&rdquo; language, Elixir is already right now a <strong>rock-solid foundation to build any ambitious web application</strong>.</p>

<p>You know, if you would spend even one third of the efforts and time you&rsquo;re spending right now to fix Ruby to try your ideas in Elixir, you would see a much greater ROI. Promised. You would complain less, you would sleep better and you&rsquo;ll feel more productive.</p>

<p>I think it is nice to increase the quality of your life by switching languages, don&rsquo;t you think?</p>

<p>Anywhoo, no hard feelings&hellip; I was in your position a couple years ago, defending Ruby. And you have invested over 8 years of your life into that community, so its hard to see new opportunities outside of it&hellip; I can totally relate to that.</p>

<p>Please invest 5 minutes of your time and try following:</p>

<pre><code class="language-text">  # try to install Elixir on your system:
  #   http://elixir-lang.org/install.html (2-3 minutes)
  # checkout Phoenix
  $ git clone https://github.com/phoenixframework/phoenix.git
  $ cd phoenix
  $ mix deps.get
  $ mix test

  # see the tests passing...
  # open the folder in a text editor and try to break anything...
  # run tests and see if they catch that error you introduce and how quickly that happens...

  # Now, this is a high level webframework with a similar initial productivity curve like Rails, so you get from idea to something running quite fast... But it does not slow down later, and you can fix any issue with the framework itself quite fast, because of the rapid feedback cycle...

</code></pre>

<p>Sorry for so much text to read. I think it is important to realize that at a certain point <strong>investing more time does not yield better results</strong>&hellip; It&rsquo;s a better strategy to switch to an alternative, that provides <strong>greater return for any invested time unit</strong>.</p>

<p>When I have started Ruby / Rails, nobody in my local community knew it and used it, so <strong>I was that Ruby fanboy back then, before it was cool</strong>. I loved it, but now the tide has turned&hellip; I have faced <strong>quite a few teams fighting the &ldquo;Rails Way&rdquo;</strong>, plagued by <strong>slow tests suites</strong>, contemplating <strong>microservices architecture</strong>&hellip; If your language does not provide the neccessary primitives to build distributed systems, <strong>you&rsquo;ll end up reimplementing half of Erlang OTP, poorly, riddled with bugs</strong>&hellip; And you won&rsquo;t have a good time maintaining that system&hellip; Been there, done that. ;)</p>

<p>So Piotr, I really hope you consider investing your creativity and energy at least partially into Elixir, you might come to like it.</p>

<p>All the best, Roman</p>

<hr>

<p>P.S:</p>

<p>After writing that response I cared to google some videos by Piotr Solnica, and this is what I&rsquo;ve found - published on <sup>2015</sup>&frasl;<sub>11</sub>:</p>

<p>
<div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/KiIukkDvn8o" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" allowfullscreen frameborder="0"></iframe>
 </div>


<div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;">
  <iframe src="//www.youtube.com/embed/rMxurF4oqsc" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;" allowfullscreen frameborder="0"></iframe>
 </div>
</p>

<p>It looks like Piotr is already feeling the need for a better language than Ruby&hellip; Give Elixir a try ;)</p>

                </section>
            </article>
            <footer id="post-meta" class="clearfix">
                
                <div>
                    <p>Author:</p>
                    <p>Roman Heinrich - Hopeless practitioner in search for the perfect prog language...</p>
                </div>
                

                
                        <img class="avatar" src="http://ruby2elixir.github.io/images/avatar.png">
                        <div>
                            <span class="dark">RUBY 2 ELIXIR</span>
                            <span></span>
                        </div>
                    
                <section id="sharing">
                    <a class="twitter" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fruby2elixir.github.io%2fposts%2f2015%2f12-18-response-to-negative-feedback-for-post-yesterday-open-letter-to-piotr-solnica.html - Response%20to%20Negative%20Feedback%20for%20Post%20Yesterday%3a%20Open%20Letter%20to%20Piotr%20Solnica "><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

                </section>

                <section id="twitter-site">
                    <a href="https://twitter.com/ruby2elixir" class="twitter-follow-button" data-show-count="true" data-size="large">Follow @ruby2elixir</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

                </section>
            </footer>

            
                <section class="disqus">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_shortname = 'ruby2elixir';
        var disqus_developer = 0; 
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="//disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>
            

            <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>
    
    
        
   
    
        
        <li>
            <a href="http://ruby2elixir.github.io/posts/2015/12-17-elixir-vs-ruby---code-quality.html">Elixir vs Ruby - Code quality<aside class="dates">Dec 17</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="http://ruby2elixir.github.io/posts/2015/11-25-why-even-bother-to-rewrite-your-rails-application-in-elixir.html">Why Even Bother to Rewrite Your Rails Application in Elixir<aside class="dates">Nov 25</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="http://ruby2elixir.github.io/about.html">About<aside class="dates">Nov 24</aside></a>
        </li>
        
   
</ul>
            <footer id="footer">
    <p class="small">
        © Copyright 2015 RUBY 2 ELIXIR
    </p>
</footer>
        </section>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="http://ruby2elixir.github.io/js/main.js"></script>
<script src="http://ruby2elixir.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>


<!-- Google Analytics -->
<script>
  var _gaq=[['_setAccount','UA-71514130-1'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>

    </body>
</html>
