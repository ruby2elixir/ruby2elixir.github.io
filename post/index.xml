<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ruby 2 Elixir Blog</title>
    <link>http://ruby2elixir.github.io/post.html</link>
    <description>Recent content in Posts on Ruby 2 Elixir Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 29 Dec 2015 18:36:00 +0100</lastBuildDate>
    <atom:link href="http://ruby2elixir.github.io/post.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Why do developers pick Elixir?</title>
      <link>http://ruby2elixir.github.io/posts/2015/12-29-why-do-developers-pick-elixir.html</link>
      <pubDate>Tue, 29 Dec 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/12-29-why-do-developers-pick-elixir.html</guid>
      <description>

&lt;p&gt;It seems like my recent blog posts reached quite the opposite of my intentions: instead of convincing people to give Elixir a try most visitors left angry comments about zealotry and stupidness and childishness displayed in my arguments.&lt;/p&gt;

&lt;p&gt;





&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      centered
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/are-you-serious-wtf-meme-baby-face-600x400.jpg&#34;

     height=&#34;100%&#34; 
     width=&#34;200&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      centered
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/the_fuck_like_twelve.jpg&#34;

     height=&#34;100%&#34; 
     width=&#34;200&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      centered
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/wtf-is-this-shit.jpg&#34;

     height=&#34;100%&#34; 
     width=&#34;200&#34; 
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;
Sigh... Well, gotta learn from my mistakes for the next blog post.
&lt;/p&gt;
&lt;p&gt;
Until then before 2015 is over I decided to compile a list from other developers who might have done a better job describing why they are so excited to work with Elixir and what problems does it solve for them.
&lt;/p&gt;
&lt;p&gt;
The list is chronologically sorted from most recent to oldest articles. I hope this will be useful for anybody thinking what new programming language  to try in 2016.

Cheers and please be awesome!
&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&#34;#amber&#34;&gt;AmberBit - When to choose Elixir over Ruby for 2016 projects? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#akita&#34;&gt;Fabio Akita - The Obligatory “Why Elixir?” Personal Take (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#clark-kampfe&#34;&gt;Clark Kampfe - Elixir is not Ruby (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#john-orford&#34;&gt;John Orford - 10 Reasons To Use Elixir In Finance (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#david-cristofaro&#34;&gt;David Cristofaro - Drinking the Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#jerel-unruh&#34;&gt;Jerel Unruh - Why I&amp;rsquo;m excited about Elixir and Phoenix (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#chris-nelson&#34;&gt;Chris Nelson -  4 Reasons We’re Having Fun Programming Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#luc-fueston&#34;&gt;Luc Fueston - The (Real) Reason I Like Elixir  (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#luke-imhoff&#34;&gt;Luke Imhoff - Why Elixir? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#jan-dudulski&#34;&gt;Jan Dudulski - We all are going to meet in the Elixir world (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#aaron-lebo&#34;&gt;Aaron Lebo - The UNIX Philosophy and Elixir as an Alternative to Go (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#lau-taarnskov&#34;&gt;Lau Taarnskov - Elixir - The next big language for the web (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;) &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#josh-smith&#34;&gt;Josh Smith - Functional parallel programming in Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#ken-mazaika&#34;&gt;Ken Mazaika - Why I’m betting on Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#paul-schoenfelder&#34;&gt;Paul Schoenfelder - What Is Elixir, and Why Do I Care? (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#sasa-juric&#34;&gt;Saša Jurić -  Why Elixir  (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#alexei-sholik&#34;&gt;Alexei Sholik - Introducing Elixir (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;08&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&#34;#devin-torres&#34;&gt;Devin Torres - Elixir: It’s Not About Syntax (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;hr&gt;&lt;/p&gt;

&lt;p&gt;&lt;h4 id=&#34;amber&#34;&gt;Ruby team at AmberBit  - Announcing Elixir Cocktails + When to choose Elixir over Ruby for 2016 projects?&lt;/h4&gt;
- &lt;a href=&#34;https://www.amberbit.com/blog/2015/7/24/announcing-elixir-cocktails/&#34;&gt;https://www.amberbit.com/blog/2015/7/24/announcing-elixir-cocktails/&lt;/a&gt;
- &lt;a href=&#34;https://www.amberbit.com/blog/2015/12/22/when-choose-elixir-over-ruby-for-2016-projects&#34;&gt;https://www.amberbit.com/blog/2015/12/22/when-choose-elixir-over-ruby-for-2016-projects&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
    We are mostly happy with Ruby and Rails, but the language, and the framework are facing some serious problems. Some of us do not believe those problems can be resolved, and there is the need for new platform for more reliable, faster and more concurrent applications.
&lt;/blockquote&gt;
...

&lt;blockquote&gt;
    Elixir runs on Erlang VM, and solves some serious problem Ruby has now. It does support actor-model concurrency mechanism. There is no Global Interpreter Lock. It comes with it’s own persistence solutions, handles distributed systems way better than Ruby, provides way to run programs on Windows servers and allows bundling compiled programs into releases. It runs fast, way faster than Ruby code. Does not choke on a hundred concurrent websocket connections. At some point we were missing all of those features when working with Ruby. We can solve those problems now, with Elixir.
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;blockquote&gt;
    The web changed a lot since the year 2006.

    Users’ expectations about web apps changed too. People don’t want to wait or reload page to see the effect. They want to see more and more live/instant updates.

    We have been joking about making a “real-time Rails app” template that integrates Faye, share.js and couple of other useful tools into the standard stack. In fact, this is where Rails slowly evolved in the end by introducing ActionCable.

&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;When to pick Elixir?&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
    &lt;h5&gt;1. High-traffic systems&lt;/h5&gt;

    Elixir applications can respond in microseconds instead. This can be put to great use. You can handle more requests on the same hardware.


    &lt;h5&gt;2. Systems that do stuff asynchronously&lt;/h5&gt;

      You can design all sorts of asynchronous systems easier in Elixir. Your developers will have to write less code. They will re-use existing patterns and libraries rather than trying to re-invent the wheel.

    &lt;h5&gt;3. Distributed / clustered systems&lt;/h5&gt;

      Erlang and Elixir rely on message passing rather than function calls and sharing state. This makes it perfect for building systems, that are decentralized and fault tolerant.

    &lt;h5&gt;4. High-availability systems with true zero-downtime&lt;/h5&gt;
      Elixir can help you maintain 100% up-time, while still delivering updates to the production system.

    &lt;h5&gt;5. Server-side push and real-time applications&lt;/h5&gt;
      We do know, that Phoenix channels do scale really nicely already.

    &lt;h5&gt;6. Large applications&lt;/h5&gt;

      If the code base of your application is expected to be large, go with Elixir without further thinking. Elixir has a built-in tools, such as umbrella projects that allow you to split the code base into chunks. You can do similar thing with Ruby’s gems, but there is fundamental difference in philosophy behind.
      I found maintaining the large code bases one of the greatest challenges. Developers do appreciate a system that facilitates tools making it easier from day 1.

    &lt;h5&gt;7. When you need smart, experienced developers&lt;/h5&gt;
      Your stack of choice can be a filter for the developers you are hiring. I am observing experienced developers migrating from Ruby to Elixir or Clojure these days.
      There is way less Elixir developers out there, but if they took their time to learn new stack, that’s a good sign of their skills.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;akita&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;fabio-akita-the-obligatory-why-elixir-personal-take-2015-12-http-www-akitaonrails-com-2015-12-01-the-obligatory-why-elixir-personal-take:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Fabio Akita - The Obligatory &amp;ldquo;Why Elixir?&amp;rdquo; Personal Take (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;12&lt;/sub&gt;) - &lt;a href=&#34;http://www.akitaonrails.com/2015/12/01/the-obligatory-why-elixir-personal-take&#34;&gt;http://www.akitaonrails.com/2015/12/01/the-obligatory-why-elixir-personal-take&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;It is a long article with many nuanced details, here are only the Elixir-relevant parts&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;

      &#34;Functional&#34; Concepts that Really Matter
        &lt;h6&gt;Immutability and Opaque Message Passing are VERY important&lt;/h6&gt;
        &lt;h6&gt;Coroutines and Schedulers&lt;/h6&gt;
        &lt;h6&gt;Static vs Dynamic Typing is still controversial&lt;/h6&gt;
        &lt;h6&gt;Fault Tolerance: Don&#39;t fear your code&lt;/h6&gt;
      &lt;hr&gt;
      Erlang has everything, as Joe Armstrong envisioned a fault tolerant system to be.


      &lt;p&gt;

      &lt;strong&gt;Elixir is the missing piece, the Philosopher&#39;s Stone&lt;/strong&gt; if you will, that can unlock all the 30 years of refinements, maturity, industry battle tested technologies in large scales, to the average programmer.
      &lt;/p&gt;

      &lt;p&gt;
      It brings many modern construct such as making macros easier in order to allow for Domain Specific Languages, having testable comments in your code, adding a more modern standard library that is easily recognizable from a Ruby or Clojure point of view, polymorphism through Protocols, and so on.
      &lt;/p&gt;
      &lt;p&gt;
      Erlang is a whole system, it has its own scheduling system, it controls living, breathing processes that each has its own garbage collector, it controls system signal trapping and so on. It was designed to be a full server.
      &lt;/p&gt;
      &lt;p&gt;
      Also because it prioritizes correctness, rigidly isolated processes communicating just by opaque messages, immutable and non-shared states, it means that Erlang is not suited to hard data science processing.
      &lt;/p&gt;
      &lt;br&gt;
      Erlang is good for distributed systems, with high concurrency of opaque message exchange and proxing. The exact scenario where the Web is. Web Applications heavy load of throughput that need real time chats and notifications, heavy and time consuming payment transactions, gathering of data from many sources in order to reduce them to consumable HTML or JSON responses.
      &lt;br&gt;
      &lt;hr&gt;
      Now we can have the comfort of a real modern language with hints of Ruby and Clojure, without the complexities of strong typing but with the security of its built-in Fault Tolerance constructions in order to deliver highly reliable, highly scalable, modern Web applications.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;clark-kampfe&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;clark-kampfe-elixir-is-not-ruby-2015-11-https-zeroclarkthirty-com-2015-11-01-elixir-is-not-ruby-html:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Clark Kampfe - Elixir is not Ruby (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;https://zeroclarkthirty.com/2015-11-01-elixir-is-not-ruby.html&#34;&gt;https://zeroclarkthirty.com/2015-11-01-elixir-is-not-ruby.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  In Ruby, one moves through a monolithic call stack, manipulating objects.


  Elixir (and every other language on the BEAM virutal machine) is built around processes.
  The defining features of a process are its memory independence and the asynchronicity of its execution.
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
  To program Elixir is to program in a functional style.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;the function as the primary abstraction&lt;/li&gt;
&lt;li&gt;immutability of data&lt;/li&gt;
&lt;li&gt;referential transparency&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;&lt;/p&gt;

&lt;p&gt;The idiom in Ruby is overwhelmingly to mutate state.
  The amount of Ruby code I have seen that is concurrent at the application level is vanishingly small, and given the prominence of the above patterns and others, it isn&amp;rsquo;t difficult to see why.&lt;/p&gt;

&lt;p&gt;Ruby and Elixir encourage behaviors as different as prank calls and ballet.
&lt;/blockquote&gt;
&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
    Both languages place value on what is known in the Ruby community as &#34;programmer happiness&#34;.


    As an Erlang, Elixir and its runtime come from a family whose main concerns are reliability, consistency, and concurrency. It is a community that is obsessed with failure: understanding it, preparing for it, and embracing it. Things fall apart.


    Ruby is hugely popular among solo developers, consultancies, startups and beginners. That is, programmers who are generally concerned more with time-to-market and short-term ROI rather than maintenance.
&lt;/blockquote&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
    Elixir is poised to walk off with Ruby&amp;rsquo;s bacon, as it fuses these two mentalities: systems that run for years should be as enjoyable to build as a NetHack clone.
&lt;/blockquote&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;john-orford&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;john-orford-10-reasons-to-use-elixir-in-finance-2015-11-http-blog-johnorford-com-2015-11-01-x-reasons-to-use-elixir-in-finance:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;John Orford - 10 Reasons To Use Elixir In Finance (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://blog.johnorford.com/2015/11/01/x-reasons-to-use-elixir-in-finance/&#34;&gt;http://blog.johnorford.com/2015/11/01/x-reasons-to-use-elixir-in-finance/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;1. Syntax&lt;/h5&gt;

      Ruby looks and feels right. Elixir has the same mindset and looks beautiful.
    &lt;h5&gt;2. Semantics&lt;/h5&gt;
       Elixir&#39;s compiles down into the Erlang virtual machine (EVM)
    &lt;h5&gt;3. Massively Parallel&lt;/h5&gt;
      Want to keep track of a large portfolio of stocks? Easy. Want to keep track of the whole market? No sweat.
    &lt;h5&gt;4. Stable&lt;/h5&gt;
      How? Massive parallelism also results in massive redundancy.
    &lt;h5&gt;5. Distributed&lt;/h5&gt;
      Elixir has distributed computing included out of the box.
    &lt;h5&gt;6. Modern&lt;/h5&gt;
      Elixir comes without all the cruft but with all the experience.
    &lt;h5&gt;7. Efficiency&lt;/h5&gt;
      Why? Because utilising multicore systems is surprisingly tricky for C# or Java developers.
    &lt;h5&gt;8. Future Proof&lt;/h5&gt;
      Rather than re-engineering, Elixir gives us a get out.
    &lt;h5&gt;9. Pipes&lt;/h5&gt;
      Its pipe operator |&gt; is simple and extremely appealing.
    &lt;h5&gt;10. Young&lt;/h5&gt;
      On the one hand this means that there are not many quantitative libraries - but it also means you can get in on the ground floor.

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;jerel-unruh&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;jerel-unruh-why-i-m-excited-about-elixir-and-phoenix-2015-11-http-jerel-co-blog-2015-11-why-im-excited-about-elixir-and-phoenix:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Jerel Unruh - Why I&amp;rsquo;m excited about Elixir and Phoenix (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://jerel.co/blog/2015/11/why-im-excited-about-elixir-and-phoenix&#34;&gt;http://jerel.co/blog/2015/11/why-im-excited-about-elixir-and-phoenix&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Jerel Unruh is a Python developer learning Elixir. He is excited about realtime possibilities in Phoenix and the functional approach to structure your applications with Plugs and data transformations of your &lt;strong&gt;conn&lt;/strong&gt;-datastructure.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Phoenix is functional. Every backend framework I&#39;d used before was object oriented and I assumed functional programming, the GNU project, and Gentoo had a lot in common. It&#39;s turning out to be quite user friendly and really nice...
  &lt;/p&gt;
  &lt;p&gt;
  As mentioned in the example above you have data (a connection) that you perform transformations on until it reaches the state you want. In Phoenix these steps of transformations are called Plugs which are Elixir modules with functions init (compile time) and call (run time) defined. Plugs are not entirely unlike middleware in other frameworks but in Phoenix almost everything is a plug. CSRF protection in the framework? A plug. Body parsing in the framework? A plug. Authentication in your code? Write a plug. Permissions? Write a plug. Do you want different permissions in a couple controllers? Include a plug in those controllers. If you don&#39;t like something that the framework does then swap out that plug. You starting to get the picture? :) And if at any point you wonder what the state of your app is you can IO.inspect(conn) and everything is there, as data.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;david-cristofaro&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;david-cristofaro-drinking-the-elixir-2015-11-http-dtcristo-com-drinking-the-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;David Cristofaro - DRINKING THE ELIXIR (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;) - &lt;a href=&#34;http://dtcristo.com/drinking-the-elixir&#34;&gt;http://dtcristo.com/drinking-the-elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;Elixir:&lt;/h5&gt;
  &lt;ul&gt;
    &lt;li&gt;A natural syntax inspired by Ruby.&lt;/li&gt;
    &lt;li&gt;Lazy evaluation from Haskell.&lt;/li&gt;
    &lt;li&gt;Protocols, macros and pipelines from Clojure.&lt;/li&gt;
    &lt;li&gt;Functional programming&lt;/li&gt;
    &lt;li&gt;Extensibility&lt;/li&gt;
    &lt;li&gt;Modern tooling&lt;/li&gt;
    &lt;li&gt;Full compatibility with Erlang&lt;/li&gt;
  &lt;/ul&gt;

  The result of all of this is a truly modern, practical and performant language on a platform capable of supporting even the most ambitious projects.

  &lt;h5&gt;Phoenix rises&lt;/h5&gt;

    &lt;p&gt;
    Phoenix is built for speed. Response times are measured in the microsecond. With Phoenix, don’t have to sacrifice performance for the sake of productivity. You can have your cake and eat it.
    &lt;/p&gt;
    &lt;p&gt;
    Phoenix is designed with real-time applications in mind, taking full advantage of Elixir’s concurrency model.
    With the help of Phoenix, Elixir is set to be the go-to language for the web and poised to kickstart a real-time web revolution.
    &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;chris-nelson&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;team-at-gaslight-4-reasons-we-re-having-fun-programming-elixir-2015-09-by-chris-nelson-https-teamgaslight-com-blog-4-reasons-were-having-fun-programming-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Team at Gaslight - 4 Reasons We&amp;rsquo;re Having Fun Programming Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) by Chris Nelson - &lt;a href=&#34;https://teamgaslight.com/blog/4-reasons-were-having-fun-programming-elixir&#34;&gt;https://teamgaslight.com/blog/4-reasons-were-having-fun-programming-elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;The Community Is Amazing&lt;/h5&gt;
    It’s not just Dave Thomas; it’s also the amazing progress of the whole Elixir community. In the last year, the amount of progress has been really impressive.


  &lt;h5&gt;Not Object Oriented, Process Oriented&lt;/h5&gt;
    I get to reap some of the key benefits of functional programming on top a runtime that has processes as core level of abstraction.

    &lt;p&gt;
    Processes are light weight, maintain per process state, and communicate purely by passing messages. In a lot of ways, they arguably embody the original vision that the inventors of object oriented had in mind.
    &lt;/p&gt;
    &lt;p&gt;
    The other great thing about Elixir (really Erlang) processes is that they finally bring a viable answer to many of the challenges of decomposing a large system into services (microservices architecture).
    &lt;/p&gt;
    &lt;p&gt;
    Because OTP has well thought out solutions, it’s possible to break off pieces of a system into services and distribute them with much less ceremony and effort.
    &lt;/p&gt;

  &lt;h5&gt;The PEEP stack&lt;/h5&gt;
    &lt;p&gt;
    stands for Phoenix, Elixir, Ember, and PostgresSQL.

    It’s very familiar if you’re coming to it with Rails experience, and this is by design

    Phoenix feels just as productive as Rails to jump into, but there a few reasons it feels even better for building “ambitious web applications”
    &lt;/p&gt;

    &lt;p&gt;
    Building RESTful JSON APIs feels really natural, and even simpler than it does in Rails.
    &lt;/p&gt;

  &lt;h5&gt;It’s Insanely Fast&lt;/h5&gt;
    We’ve frankly struggled to get the performance out of Ruby we would like and having to fight with this less would make us very happy.
    &lt;p&gt;
    And lest you think “Does Telco experience translate to web apps?” it’s worth checking out this about the WhatsApp engineering team from a few years back.
    &lt;/p&gt;

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;luc-fueston&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;luc-fueston-the-real-reason-i-like-elixir-2015-09-http-blog-maketogether-com-the-real-reason-i-like-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Luc Fueston - The (Real) Reason I Like Elixir  (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;09&lt;/sub&gt;) - &lt;a href=&#34;http://blog.maketogether.com/the-real-reason-i-like-elixir/&#34;&gt;http://blog.maketogether.com/the-real-reason-i-like-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Luc Fueston likes the Lispy-ness of Elixir and thinks that &amp;ldquo;Macros are the Hammer that Jose Used to Nail It&amp;rdquo;.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;luke-imhoff&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;luke-imhoff-why-elixir-2015-07-https-kronicdeth-github-io-why-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Luke Imhoff - WHY ELIXIR? (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;) - &lt;a href=&#34;https://kronicdeth.github.io/why-elixir/&#34;&gt;https://kronicdeth.github.io/why-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Functional Programming:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Mathematical functions&lt;/li&gt;
&lt;li&gt;Avoids changing state&lt;/li&gt;
&lt;li&gt;Immutable data&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Elixir:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Modules + Functions&lt;/li&gt;
&lt;li&gt;Pattern Matching + Guards&lt;/li&gt;
&lt;li&gt;Recursion&lt;/li&gt;
&lt;li&gt;Concurrency&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tooling:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;mix&lt;/li&gt;
&lt;li&gt;ExUnit&lt;/li&gt;
&lt;li&gt;ExDoc&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Macros:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Capture code&lt;/li&gt;
&lt;li&gt;Compile data into code&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Protocols + Pipes + Process Scaling&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;aaron-lebo&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;aaron-lebo-the-unix-philosophy-and-elixir-as-an-alternative-to-go-2015-06-http-lebo-io-2015-06-22-the-unix-philosophy-and-elixir-as-an-alternative-to-go-html:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Aaron Lebo - The UNIX Philosophy and Elixir as an Alternative to Go (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) - &lt;a href=&#34;http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html&#34;&gt;http://lebo.io/2015/06/22/the-unix-philosophy-and-elixir-as-an-alternative-to-go.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Elixir is a very light Ruby-ish layer of syntax that compiles down to run on BEAM, the Erlang VM.&lt;/h5&gt;

    &lt;br&gt;
    &lt;p&gt;
    What I do want to touch on are the qualities of Elixir itself. Do you want a modern language? Elixir is functional, immutable, and supports pattern matching, which is like a case or if statement on steroids, only that explanation doesn&#39;t begin to touch how much it impacts your entire manner of coding. It also supports macros which means that the core language can remain small but users can extend the syntax to support patterns the designer never dreamed of. As I said before, it does this with a Ruby-ish syntax.
    &lt;/p&gt;
    &lt;p&gt;
    Despite the fact that it is a very modern language, it is quite small.
    You can read through the language guide in a few hours and have a pretty good grasp on the core concepts
    This also leads to much quicker mastery. Use 10 constructs 100 times each and you&#39;ll get them intuitively much faster than if you use 100 constructs 10 times each.
    &lt;/p&gt;
    &lt;hr&gt;
    Elixir brings so many features which will both make you grow as a programmer and will help your programs to grow elegantly in the future.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;jan-dudulski&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;codetunes-we-all-are-going-to-meet-in-the-elixir-world-2015-06-by-jan-dudulski-http-codetunes-com-2015-we-all-are-going-to-meet-in-the-elixir-world:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Codetunes - We all are going to meet in the Elixir world (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) by Jan Dudulski - &lt;a href=&#34;http://codetunes.com/2015/we-all-are-going-to-meet-in-the-elixir-world/&#34;&gt;http://codetunes.com/2015/we-all-are-going-to-meet-in-the-elixir-world/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;&amp;hellip;
&lt;blockquote&gt;
  &lt;p&gt;
  I attended ElixirConf.eu in April. About 95% of attendees came from the Ruby world. I spoke with many of them and each were speaking the same way - they’re looking for something better. They’re tired of Rails&amp;rsquo; monolithic design, struggling with thread safety and heavy processes.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
  And Elixir seems to be a perfect solution for us, tired Rubists. Beautiful syntax, functional paradigm, successful Erlang VM, incredible performance, dozens of very smart people behind it - this is just the tip of the iceberg and the reason why a lot of devs are so excited already.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
    During the conference I heard a story from guys who were able to stop worrying about cache completely - Elixir was so fast! About a painful - at first sight - migration because of missing tools, but also about the ease of building support for them or replacing them with a better toolset. I saw real enjoyment about the possibilities and pleasure of hacking around - e.g. playing with lego robots. I enjoyed every talk and, for me, it was the most inspiring conference I’ve ever attended.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
    You will love the fail fast strategy. You will love pattern matching. You will love pipe operator. You will love Ecto and Phoenix. You will love compilator and no more runtime errors. You will love Erlang Processes and how easy it is to just run something in the background.
  &lt;/p&gt;
  &lt;p&gt;
    And you will never want to go back.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;/blockquote&gt;&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;lau-taarnskov&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;lau-taarnskov-elixir-the-next-big-language-for-the-web-2015-04-http-www-creativedeletion-com-2015-04-19-elixir-next-language-html:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Lau Taarnskov - Elixir - The next big language for the web (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;) - &lt;a href=&#34;http://www.creativedeletion.com/2015/04/19/elixir_next_language.html&#34;&gt;http://www.creativedeletion.com/2015/04/19/elixir_next_language.html&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;

    &lt;h5&gt;From obscurity to the default choice&lt;/h5&gt;
      Rails took Ruby out of obscurity and some years later even many non-programmers had heard about this web framework.
      It was very interesting to see how quickly Rails went from being used by a handful of people to being the “it-framework” and the default choice for startups that needed web based software.

    &lt;h5&gt;Elixir&lt;/h5&gt;
      Elixir has its own package management system, macros, an easy to use build tool and unicode handling.
      Elixir is a language that runs on the Erlang VM.
      So it has all of the benefits of the mature, battle proven system and you can use the existing Erlang libraries with no performance penalty.


    &lt;h5&gt;Immutability and functional programming&lt;/h5&gt;
       Functional programming and immutability helps to clarify things and makes it easier to reason about code.

    &lt;h5&gt;Concurrency&lt;/h5&gt;
      The trend in hardware is more and more CPU cores.
      Doing concurrency in Erlang or Elixir versus other languages is a bit like doing branches in Git vs Subversion
      In Elixir it is very easy to create a new process and it performs very well

    &lt;h5&gt;Web framework&lt;/h5&gt;
      Phoenix is the most popular web framework for Elixir right now.
      One of the most exciting features is the real time capabilities with channels between javascript on the client and Elixir on any of the servers in the cluster.
      Efficiency and speed are important for the end user experience, and also means less waste of energy and money on servers.

    &lt;h5&gt;Programmer happiness and beautiful code&lt;/h5&gt;
      With Elixir I do not feel like I trade any joy or speed of development for the performance, reliability and concurrency benefits of the Erlang VM. Elixir provides all of the Erlang benefits such as performance and reliability without giving up the productivity benefits of Ruby.

    &lt;h5&gt;Déjà vu&lt;/h5&gt;
      Like with Ruby 12 years ago, once again I feel that this new platform is so much better than the other solutions.

      I think it is likely that in a few years Elixir instead will be the go-to language for new web projects.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;josh-smith&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;josh-smith-functional-parallel-programming-in-elixir-2015-03-http-ijoshsmith-com-2015-03-14-functional-parallel-programming-in-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Josh Smith - Functional parallel programming in Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;) - &lt;a href=&#34;http://ijoshsmith.com/2015/03/14/functional-parallel-programming-in-elixir/&#34;&gt;http://ijoshsmith.com/2015/03/14/functional-parallel-programming-in-elixir/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;h5&gt;Why Elixir?&lt;/h5&gt;

  &lt;p&gt;
  Over the past few months I studied various functional programming languages, as well as the concurrency and parallel programming models their practitioners espouse.
  &lt;/p&gt;
  &lt;p&gt;
  While certainly seeing value in each language I studied, only Elixir jumped out at me as elegant and expressive yet simple. It is a so-called impure functional language, meaning that it is built to support a functional programming style but also allows for symbols that can change value
  &lt;/p&gt;

  &lt;p&gt;
  Elixir is a modern language that enables today’s mainstream developers to harness the highly concurrent, fault-tolerant, distributed, bulletproof Erlang virtual machine that undergirds much of the telecommunication infrastructure on which our society depends.
  &lt;/p&gt;

  &lt;p&gt;
  After a few days of writing Elixir code, I was impressed. Once I saw firsthand how Elixir and the Erlang VM simplify multi-core computing, I was sold. I don’t expect to write Elixir code for a living any time soon, if ever, but the lessons I learn from the language and platform can be adopted in my daily software development practices. I wrote this article to share those lessons with others.
  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;ken-mazaika&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;ken-mazaika-why-i-m-betting-on-elixir-2015-01-https-medium-com-kenmazaika-why-im-betting-on-elixir-7c8f847b58:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Ken Mazaika - Why I’m betting on Elixir (&lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;) - &lt;a href=&#34;https://medium.com/@kenmazaika/why-im-betting-on-elixir-7c8f847b58&#34;&gt;https://medium.com/@kenmazaika/why-im-betting-on-elixir-7c8f847b58&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Package Management with Mix&lt;/h5&gt;
      Mix just does its job nicely, stays out of the way, and doesn’t force you to wrangle XML.

    &lt;h5&gt;The Erlang Virtual Machine&lt;/h5&gt;
      emphasis on functional programming that are fault-tolerant and highly scalable.


    &lt;h5&gt;The Phoenix Web Framework&lt;/h5&gt;
      Phoenix is such a Railsy solution you’ll feel like you’re building a Rails app, with the exception being that it runs with Elixir and has all the benefits of Elixir and the Erlang virtual machine.

    &lt;h5&gt;Strong Leadership&lt;/h5&gt;
      In my opinion, the difference between open source and movement, is all around the leadership involved in the project. In short, I believe really smart people need to be putting the work in to improve the software every single day.

      Jose Valim, Chris McCord, and all the members of the Elixir-Lang core team and Phoenix core team have, and continue to put in the work that needs to be done for the Elixir community to thrive.

    &lt;h5&gt;The web is about to under-go a transformational change&lt;/h5&gt;
      The people who will win are going to be the ones who embrace changes in technology. The fact that WebSockets, processes, and concurrency in Phoenix and Elixir are cheap, without sacrificing developer happiness is an absolute game-changer.
&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;paul-schoenfelder&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;paul-schoenfelder-what-is-elixir-and-why-do-i-care-2014-03-http-bitwalker-org-elixir-erlang-programming-tutorials-2014-03-10-what-is-elixir-and-why-do-i-care:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Paul Schoenfelder - What Is Elixir, and Why Do I Care? (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;) - &lt;a href=&#34;http://bitwalker.org/elixir/erlang/programming/tutorials/2014/03/10/what-is-elixir-and-why-do-i-care/&#34;&gt;http://bitwalker.org/elixir/erlang/programming/tutorials/2014/03/10/what-is-elixir-and-why-do-i-care/&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Paul Schoenfelder is productive in C#, Ruby, Python, Javascript, Scala, Clojure, C and C++, but he thinks Elixir provides something, that all the other languages do not&amp;hellip;&lt;/p&gt;

&lt;blockquote&gt;
    &lt;h5&gt;Elixir’s Elevator Pitch&lt;/h5&gt;
    Elixir is a functional, metaprogrammable language, built for productivity, extensibility, and to take advantage of Erlang’s simple but powerful fault-tolerance and concurrency primitives. It is composed of a simple core language, with syntax that is very reminiscent of Ruby (and no wonder, as its creator José Valim, is a Ruby core committer, and author of many Ruby libraries such as Devise). However, despite the aesthetic similarity to Ruby, the semantics of Elixir are quite different.



    &lt;h5&gt;At a high level, Elixir provides the following features:&lt;/h5&gt;
    &lt;ul&gt;
      &lt;li&gt;Modules&lt;/li&gt;
      &lt;li&gt;First-class functions&lt;/li&gt;
      &lt;li&gt;Pattern matching (amazing)&lt;/li&gt;
      &lt;li&gt;Protocols, which provide polymorphism for your data types.&lt;/li&gt;
      &lt;li&gt;Macros. If you dig in to Elixir’s source code, you will see that the vast majority of the language’s syntax is - actually defined as simple Elixir macros: if, unless, cond, etc. Incredibly powerful feature.&lt;/li&gt;
      &lt;li&gt;Everything is an expression, this makes it easy to compose code without intermediate variables.&lt;/li&gt;
      &lt;li&gt;Immutability&lt;/li&gt;
      &lt;li&gt;Pipes. Instead of defining code inside-out like: &lt;span class=&#34;code&#34;&gt;Date.shift(Date.new({2014, 10, 5}), days: 10)&lt;/span&gt; pipes allow you - to write it as you would say it: &lt;span class=&#34;code&#34;&gt;{2014, 10, 5} |&gt; Date.new |&gt; Date.shift(days: 10)&lt;/span&gt;. Code becomes very easy to read.&lt;/li&gt;
      &lt;li&gt;Dead simple concurrency.&lt;/li&gt;
      &lt;li&gt;Dead simple clustering/distribution.&lt;/li&gt;
      &lt;li&gt;Built-in unit testing&lt;/li&gt;
      &lt;li&gt;First-class documentation (including the ability to test the code examples in your docs!)&lt;/li&gt;
      &lt;li&gt;Excellent build tool (modeled after Leiningen for Clojure, very similar to Rake for Ruby)&lt;/li&gt;
      &lt;li&gt;Excellent documentation and community&lt;/li&gt;
    &lt;/ul&gt;


&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;sasa-juric&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;saša-jurić-why-elixir-2014-01-http-theerlangelist-com-article-why-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Saša Jurić - Why Elixir - (&lt;sup&gt;2014&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;) - &lt;a href=&#34;http://theerlangelist.com/article/why_elixir&#34;&gt;http://theerlangelist.com/article/why_elixir&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
    &lt;strong&gt;Elixir is not Ruby for Erlang.&lt;/strong&gt;

    To me, it is an Erlang-like language with improved code organization capabilities. This definition differs from what you’ll see on the official page, but I think it captures the essence of Elixir, when compared to Erlang.

      &lt;h5&gt;Metaprogramming&lt;/h5&gt;
         It allows us to write concise constructs that seems as if they’re a part of the language. These constructs are in compile-time then transformed into a proper code.

      &lt;h5&gt;Pipeline operator&lt;/h5&gt;
        The pipeline operator works extremely well because the API in Elixir libraries follows the “subject (noun) as the first argument” convention.

      &lt;h5&gt;Polymorphism via protocols&lt;/h5&gt;
        Protocols are the Elixir way of providing something roughly similar to OO interfaces

      &lt;h5&gt;The mix tool&lt;/h5&gt;
        help us manage projects

      &lt;h5&gt;Syntactical changes&lt;/h5&gt;
        support for variable rebinding, optional parentheses, implicit statement endings, nullability, short circuits operators...

&lt;/blockquote&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;alexei-sholik&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;alexei-sholik-introducing-elixir-2013-08-http-alexeisholik-com-elixir-talk:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Alexei Sholik - Introducing Elixir (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;08&lt;/sub&gt;) - &lt;a href=&#34;http://alexeisholik.com/elixir-talk/&#34;&gt;http://alexeisholik.com/elixir-talk/&lt;/a&gt;&lt;/h4&gt;

&lt;h3 id=&#34;why-elixir:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Why Elixir?&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;No repetitive boilerplate&lt;/li&gt;
&lt;li&gt;Simple APIs&lt;/li&gt;
&lt;li&gt;DSLs&lt;/li&gt;
&lt;li&gt;Practical (code reuse, meta)&lt;/li&gt;
&lt;li&gt;User friendly (syntax; exceptions; REPL)&lt;/li&gt;
&lt;li&gt;Tools (mix, ExUnit, EEx)&lt;/li&gt;
&lt;li&gt;New, consistent stdlib&lt;/li&gt;
&lt;li&gt;Enthusiastic community&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;&lt;div id=&#34;devin-torres&#34;&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h4 id=&#34;devin-torres-elixir-it-s-not-about-syntax-2013-06-http-devintorr-es-blog-2013-06-11-elixir-its-not-about-syntax:1359706cd5718d68f22bd3e7738ac85a&#34;&gt;Devin Torres - Elixir: It&amp;rsquo;s Not About Syntax (&lt;sup&gt;2013&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;) - &lt;a href=&#34;http://devintorr.es/blog/2013/06/11/elixir-its-not-about-syntax/&#34;&gt;http://devintorr.es/blog/2013/06/11/elixir-its-not-about-syntax/&lt;/a&gt;&lt;/h4&gt;

&lt;blockquote&gt;
      &lt;h5&gt;Performance&lt;/h5&gt;

        Performance of Elixir code should match or beat the performance of equivalent Erlang code.
        &lt;p&gt;
        Elixir’s powerful metaprogramming capabilities don’t come from e.g. runtime dispatching, but the fantastically powerful compiler. All this magic happens at compilation time, before your code even has to run. And this is the part that may blow your minds: Elixir will beat the performance of Erlang in some cases.
        &lt;/p&gt;


      &lt;h5&gt;Metaprogrammability&lt;/h5&gt;
        &lt;p&gt;
        Elixir is strongly homoiconic.
        It has one of the most powerful macro system I’ve been able to find in among other macro-capable languages I’ve used to date.
        &lt;/p&gt;
        &lt;p&gt;
        Elixir macros are hygienic. This means that variables defined in a macro won’t interfere with variables defined in the local scope when you use the macro. Oh, and guess what? They are optionally unhygienic as well if you’re into that kind of thing.
        &lt;/p&gt;

        Macros shouldn’t be abused.


      &lt;h5&gt;The standard library and runtime&lt;/h5&gt;

        The Elixir standard library aims to dramatically increase the productivity of Elixir developers, while providing the extensibility and features Elixir developers expect from such a metaprogrammable language.

      &lt;h5&gt;Unafraid of change&lt;/h5&gt;

        We have Erlangers, Clojurists, Haskellers, Rubyists, and Pythonistas trying to incorporate useful features into Elixir every day. Elixir isn’t afraid of introducing functionality that improves the lives of Elixir developers, and everything is on the table: new data structures, real Unicode support, anything.

      &lt;h5&gt;Tooling&lt;/h5&gt;

        IEx, Doctests, Mix

      &lt;hr&gt;

      Elixir is the power of it’s tooling, the expressiveness of it’s metaprogrammability, and the expansive feature set of it’s standard library while maintaining complete compatibility with—and heavily leveraging—OTP.
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>Response to Negative Feedback for Post Yesterday: Open Letter to Piotr Solnica</title>
      <link>http://ruby2elixir.github.io/posts/2015/12-18-response-to-negative-feedback-for-post-yesterday-open-letter-to-piotr-solnica.html</link>
      <pubDate>Fri, 18 Dec 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/12-18-response-to-negative-feedback-for-post-yesterday-open-letter-to-piotr-solnica.html</guid>
      <description>

&lt;p&gt;EDIT:






&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      centered
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/tweet_1_josevalim.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      centered
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/tweet_2_josevalim.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Apologies to anybody offended by the following post and especially to Piotr Solnic. I feel his energy and creativity would have a more productive foundation if he chose to express his code in Elixir, but it was certainly not my intention to intimidate him. If there is public interest to take this post down, I will.&lt;/p&gt;

&lt;p&gt;Sorry for confusion!&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;Original post:&lt;/p&gt;

&lt;p&gt;My blogpost from yesterday &lt;a href=&#34;http://ruby2elixir.github.io/posts/2015/12-17-elixir-vs-ruby---code-quality.html&#34;&gt;Elixir vs Ruby - Code Quality&lt;/a&gt; seems to have upset quite some people due to its unscientific way of comparing 2 programming language code bases. Most of the criticism is right, number of open issues and outstanding pull request alone do not make a convincing argument&amp;hellip; But it got me some valuable ideas, how to convey the real facts, that I personally find fascinating and intriguing&amp;hellip;&lt;/p&gt;

&lt;p&gt;The real metric I wanted to underline is the speed of issue resolving. And the factors that play into it, like ease of bug reproduction, the speed of test suites and conceptual code flexibility.&lt;/p&gt;

&lt;p&gt;I understood this while writing a response to Piotr Solnic (&lt;a href=&#34;http://solnic.eu/&#34;&gt;http://solnic.eu/&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;While speed of issue resolving as metric is not analysed here further, I&amp;rsquo;d like to include my response to the critique of yesterday&amp;rsquo;s blog post.&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;&lt;quote&gt;
originally posted on reddit/r/ruby
  &lt;a href=&#34;https://www.reddit.com/r/ruby/comments/3x7m4h/ruby_vs_elixir_code_quality_on_github/&#34;&gt;https://www.reddit.com/r/ruby/comments/3x7m4h/ruby_vs_elixir_code_quality_on_github/&lt;/a&gt;
&lt;/quote&gt;&lt;/p&gt;

&lt;p&gt;Yes, the title is misleading, it should be more like: &lt;strong&gt;the speed of issue resolving in Ruby vs Elixir core languages&lt;/strong&gt;. By proxy this metric says something about the quality of code, but it is not directly &amp;ldquo;quality of code&amp;rdquo;. It&amp;rsquo;s hard to give precise metrics for &amp;ldquo;quality&amp;rdquo;&amp;hellip; You start to understand quality when you interact with the object in question.&lt;/p&gt;

&lt;p&gt;First commit to Elixir was in &lt;sup&gt;2011&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt; (&lt;a href=&#34;https://github.com/elixir-lang/elixir/commits/master?page=289&#34;&gt;https://github.com/elixir-lang/elixir/commits/master?page=289&lt;/a&gt;), so it is widely considered a &amp;ldquo;young&amp;rdquo; language.&lt;/p&gt;

&lt;p&gt;Elixir while being seemingly a &amp;ldquo;young&amp;rdquo; language, is getting all the benefits of 30 years old Erlang VM and the not many but very solid libraries in the Erlang ecosystem. That is a much more solid foundation than Ruby VM can ever get.&lt;/p&gt;

&lt;p&gt;Most of Elixir is implemented in Elixir, making contribution quite easy. Due to its functional nature you as developer are encouraged to structure your code in side-effect free functions transforming immutable datastructures. While being unfamiliar to most OOP programmers, this leads to more explicit and robust code.&lt;/p&gt;

&lt;p&gt;The test suite for the &lt;strong&gt;whole elixir language&lt;/strong&gt; passes in &lt;strong&gt;3 &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt; minutes&lt;/strong&gt; on travis-ci
  - &lt;a href=&#34;https://travis-ci.org/elixir-lang/elixir/builds/97507754&#34;&gt;https://travis-ci.org/elixir-lang/elixir/builds/97507754&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;core takes only 42.3 seconds&lt;/strong&gt; (time you need to run tests locally, without fresh installation):
  - &lt;a href=&#34;https://travis-ci.org/elixir-lang/elixir/builds/97507754#L383&#34;&gt;https://travis-ci.org/elixir-lang/elixir/builds/97507754#L383&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The test suite for &lt;strong&gt;phoenix&lt;/strong&gt; passes in &lt;strong&gt;1 min 38&lt;/strong&gt; sec on travis:
  &lt;a href=&#34;https://travis-ci.org/phoenixframework/phoenix/builds/97573360&#34;&gt;https://travis-ci.org/phoenixframework/phoenix/builds/97573360&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The actual suite for the &lt;strong&gt;phoenix core&lt;/strong&gt; takes only &lt;strong&gt;around 20 sec&lt;/strong&gt;:
  &lt;a href=&#34;https://travis-ci.org/phoenixframework/phoenix/builds/97573360#L381&#34;&gt;https://travis-ci.org/phoenixframework/phoenix/builds/97573360#L381&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It seems like nobody ever bothered to &lt;strong&gt;compare open source programming languages by the speed of issue resolving&lt;/strong&gt;&amp;hellip; I have a strong conviction that &lt;strong&gt;this little metric is a strong indicator for the future success&lt;/strong&gt; of that particular language. And surely it is not reflected in the numbers presented in the article yesterday because it would require much more effort to statistically evaluate a meaningful value for each resolved issue on Github. So yeah, that article is probably mostly meaningless for any serious statistical evaluation. But it emphasises something that most developers &lt;strong&gt;neglect to consider&lt;/strong&gt; when picking a new language to learn:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;number of currenly known and unresolved bugs/issues&lt;/strong&gt; in a language&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;how fast&lt;/strong&gt; are those issues resolved&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To take your argument further, one would believe that a young programming language has &lt;strong&gt;by default much less open issues due to its lesser popularity&lt;/strong&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;What about Rust: &lt;a href=&#34;https://github.com/rust-lang/rust&#34;&gt;https://github.com/rust-lang/rust&lt;/a&gt; ?&lt;/p&gt;

&lt;p&gt;It currently has &lt;strong&gt;2286 open issues and 94 outstanding pull requests&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;First commit is from &lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt; (&lt;a href=&#34;https://github.com/rust-lang/rust/commits/master?page=1395&#34;&gt;https://github.com/rust-lang/rust/commits/master?page=1395&lt;/a&gt;), only 6 months older than Elixir.&lt;/p&gt;

&lt;p&gt;Is Rust more popular? If we consider the number of stars, it is &lt;strong&gt;3x more popular than Elixir&lt;/strong&gt;. But the number of open issues is ca. &lt;strong&gt;70x (2286 / 32) higher than for Elixir. What&amp;rsquo;s going on here?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If you check the last build for Rust&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://travis-ci.org/rust-lang/rust/builds/97619789&#34;&gt;https://travis-ci.org/rust-lang/rust/builds/97619789&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;it took &lt;strong&gt;51 min 30 sec.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Just imagine the &lt;strong&gt;developer ergonomics&lt;/strong&gt;&amp;hellip; You make some changes&amp;hellip; You push to Github&amp;hellip; After nearly &lt;strong&gt;1h waiting comes the response: failed build&lt;/strong&gt;. Every attempt to fix the build will cost you ca. 1h of your life&amp;hellip; How &lt;strong&gt;many productive hours&lt;/strong&gt; do you think you will have in that kind of environment?&lt;/p&gt;

&lt;p&gt;Now contast this with the Elixir test suite. It take much less time to &lt;strong&gt;verify your changes locally&lt;/strong&gt; and it is much &lt;strong&gt;more fun to keep the build green on travis&lt;/strong&gt;, because the &lt;strong&gt;cost per iteration is intentionally kept very low&lt;/strong&gt;. This makes &lt;strong&gt;contribution by community much more likely&lt;/strong&gt;*. And the core team has much &lt;strong&gt;more time to close outstanding issues and merge pull requests&lt;/strong&gt;. You as developer can be &lt;strong&gt;in &amp;ldquo;flow&amp;rdquo; state more often&lt;/strong&gt; because the &lt;strong&gt;feedback loop is so quick&lt;/strong&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;personal-appeal:d51fd71bc356afea6bfa07cced01a01e&#34;&gt;Personal appeal&lt;/h3&gt;

&lt;p&gt;Piotr, I have read you blog posts quite often and you come across as quite controversial and forward-thinking person.&lt;/p&gt;

&lt;p&gt;If we take that quite recent post of yours:
  &lt;a href=&#34;http://solnic.eu/2015/03/04/8-things-i-learned-during-8-years-of-ruby-and-rails.html&#34;&gt;http://solnic.eu/2015/03/04/8-things-i-learned-during-8-years-of-ruby-and-rails.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;TDD: is of paramount importance, right? Elixir makes it even easier than Ruby&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;World outside of Rails:  maybe also outside Ruby?&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I have tested ALL the Ruby web microframeworks out there&amp;hellip;. They don&amp;rsquo;t help that much, but require much more time investement -&amp;gt; &lt;a href=&#34;https://github.com/luislavena/bench-micro/commits/master?page=2&#34;&gt;https://github.com/luislavena/bench-micro/commits/master?page=2&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Immutability: now we are talking! &lt;strong&gt;Immutability in Ruby&lt;/strong&gt; is well&amp;hellip; Awkward. Inefficient. Against the language philosophy. Not fun at all.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;No rules, just guidelines: Right! You should be free to structure your application in a way that is meaningful to you. Sadly most companies are embracing the &amp;ldquo;Rails Way&amp;rdquo; of doing things&amp;hellip; You&amp;rsquo;ll fight always an uphill battle to change it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Convenience has a big price: Right, if you&amp;rsquo;re talking about Rails! With Elixir / Phoenix you can keep convenience without making sacrifices in speed and developer productivity, even longterm.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mutation testing: This is not needed in Elixir, because all the data is immutable! But you can use QuickCheck for property based testing, see &lt;a href=&#34;http://www.erlang-factory.com/sfbay2015/thomas-arts&#34;&gt;http://www.erlang-factory.com/sfbay2015/thomas-arts&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Ideas behind ORM are a fallacy: RIGHT!&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;I want simple data processing. I want immutable data. When I need to build a UI it should efficiently write changes back to the database when a client sends a request to do so. And that is not an ORM.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Take a look at Ecto - &lt;a href=&#34;https://github.com/elixir-lang/ecto&#34;&gt;https://github.com/elixir-lang/ecto&lt;/a&gt; + some links here: &lt;a href=&#34;https://github.com/mindreframer/getoffrails/blob/master/ecto.md&#34;&gt;https://github.com/mindreframer/getoffrails/blob/master/ecto.md&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You get back simple data-structures. Without magic. Validation happen in changesets.&lt;/p&gt;

&lt;p&gt;It that is too much for your taste, try that one:
    &lt;a href=&#34;https://github.com/robconery/moebius&#34;&gt;https://github.com/robconery/moebius&lt;/a&gt; (only for PostgreSQL). Inspired by Sequel by Jeremy Evans. Since you&amp;rsquo;re writing a book about Roda, you&amp;rsquo;ll know him ;)&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;the-point-i-m-trying-to-make-is:d51fd71bc356afea6bfa07cced01a01e&#34;&gt;The point I&amp;rsquo;m trying to make is:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Do you think you could fix Ruby to accomodate your wishlist outlined above? How long would it take? Is it possible at all?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;THIS IS THE SAME QUESTION THAT JOSE VALIM HAD FACED. Then he tried to &lt;strong&gt;bring concepts from Erlang language to Ruby and failed&lt;/strong&gt;, unsurprisingly&amp;hellip;
So he chose to &lt;strong&gt;bring the good parts of Ruby to the Erlang VM&lt;/strong&gt;. That gave birth to Elixir. Despite being considered a &amp;ldquo;young&amp;rdquo; language, Elixir is already right now a &lt;strong&gt;rock-solid foundation to build any ambitious web application&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;You know, if you would spend even one third of the efforts and time you&amp;rsquo;re spending right now to fix Ruby to try your ideas in Elixir, you would see a much greater ROI. Promised. You would complain less, you would sleep better and you&amp;rsquo;ll feel more productive.&lt;/p&gt;

&lt;p&gt;I think it is nice to increase the quality of your life by switching languages, don&amp;rsquo;t you think?&lt;/p&gt;

&lt;p&gt;Anywhoo, no hard feelings&amp;hellip; I was in your position a couple years ago, defending Ruby. And you have invested over 8 years of your life into that community, so its hard to see new opportunities outside of it&amp;hellip; I can totally relate to that.&lt;/p&gt;

&lt;p&gt;Please invest 5 minutes of your time and try following:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-text&#34;&gt;  # try to install Elixir on your system:
  #   http://elixir-lang.org/install.html (2-3 minutes)
  # checkout Phoenix
  $ git clone https://github.com/phoenixframework/phoenix.git
  $ cd phoenix
  $ mix deps.get
  $ mix test

  # see the tests passing...
  # open the folder in a text editor and try to break anything...
  # run tests and see if they catch that error you introduce and how quickly that happens...

  # Now, this is a high level webframework with a similar initial productivity curve like Rails, so you get from idea to something running quite fast... But it does not slow down later, and you can fix any issue with the framework itself quite fast, because of the rapid feedback cycle...

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sorry for so much text to read. I think it is important to realize that at a certain point &lt;strong&gt;investing more time does not yield better results&lt;/strong&gt;&amp;hellip; It&amp;rsquo;s a better strategy to switch to an alternative, that provides &lt;strong&gt;greater return for any invested time unit&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;When I have started Ruby / Rails, nobody in my local community knew it and used it, so &lt;strong&gt;I was that Ruby fanboy back then, before it was cool&lt;/strong&gt;. I loved it, but now the tide has turned&amp;hellip; I have faced &lt;strong&gt;quite a few teams fighting the &amp;ldquo;Rails Way&amp;rdquo;&lt;/strong&gt;, plagued by &lt;strong&gt;slow tests suites&lt;/strong&gt;, contemplating &lt;strong&gt;microservices architecture&lt;/strong&gt;&amp;hellip; If your language does not provide the neccessary primitives to build distributed systems, &lt;strong&gt;you&amp;rsquo;ll end up reimplementing half of Erlang OTP, poorly, riddled with bugs&lt;/strong&gt;&amp;hellip; And you won&amp;rsquo;t have a good time maintaining that system&amp;hellip; Been there, done that. ;)&lt;/p&gt;

&lt;p&gt;So Piotr, I really hope you consider investing your creativity and energy at least partially into Elixir, you might come to like it.&lt;/p&gt;

&lt;p&gt;All the best, Roman&lt;/p&gt;

&lt;hr&gt;

&lt;p&gt;P.S:&lt;/p&gt;

&lt;p&gt;After writing that response I cared to google some videos by Piotr Solnica, and this is what I&amp;rsquo;ve found - published on &lt;sup&gt;2015&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;:&lt;/p&gt;

&lt;p&gt;
&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/KiIukkDvn8o&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;


&lt;div style=&#34;position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;//www.youtube.com/embed/rMxurF4oqsc&#34; style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%;&#34; allowfullscreen frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
 &lt;/div&gt;
&lt;/p&gt;

&lt;p&gt;It looks like Piotr is already feeling the need for a better language than Ruby&amp;hellip; Give Elixir a try ;)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Elixir vs Ruby - Code quality</title>
      <link>http://ruby2elixir.github.io/posts/2015/12-17-elixir-vs-ruby---code-quality.html</link>
      <pubDate>Thu, 17 Dec 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/12-17-elixir-vs-ruby---code-quality.html</guid>
      <description>

&lt;p&gt;A non-scientific and quick comparison of code quality between Ruby and Elixir ecosystems.&lt;/p&gt;

&lt;p&gt;This is just a snapshot in time of current bugs / issues for each language + the most prominent web framework in that ecosystem. Yeah, in theory they should not be related, but in practice it plays a huge role in driving developer adoption if you get the web framework right, so we consider it too.&lt;/p&gt;

&lt;h3 id=&#34;elixir:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Elixir&lt;/h3&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_elixir_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;Issues: 32, Pull Requests: 7&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;phoenix:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Phoenix&lt;/h3&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_phoenix_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;Issues: 5, Pull Requests: 2&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;ecto:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Ecto&lt;/h3&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_ecto_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;Issues: 22, Pull Requests: 6&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;erlang-bugs-are-kinda-hard-to-find-and-report-http-bugs-erlang-org-secure-dashboard-jspa:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Erlang (Bugs are kinda hard to find and report - &lt;a href=&#34;http://bugs.erlang.org/secure/Dashboard.jspa&#34;&gt;http://bugs.erlang.org/secure/Dashboard.jspa&lt;/a&gt;)&lt;/h3&gt;

&lt;p&gt;





&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_erlang_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_erlang_github_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Issues: 16, Pull Requests: 69&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;ruby:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;





&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_ruby_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_ruby_github_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;
&lt;/p&gt;

&lt;p&gt;Issues (only bugs): 871, Pull Requests: 119&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;rails:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Rails&lt;/h3&gt;







&lt;figure class=&#34;full_scale&#34;&gt;
    &lt;img class=&#34;
    
      full_scale
    
    &#34; src=&#34;http://ruby2elixir.github.io/media/posts/2015/status_rails_20151217.png&#34;

    
    
    /&gt;
    &lt;figcaption&gt;
        
    &lt;/figcaption&gt;
&lt;/figure&gt;


&lt;p&gt;Issues: 412, Pull Requests: 464&lt;/p&gt;

&lt;hr&gt;

&lt;h2 id=&#34;summary:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Summary:&lt;/h2&gt;

&lt;h5 id=&#34;erlang-elixir-phoenix-ecto:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Erlang + Elixir + Phoenix + Ecto&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;(32+5+16+22)   = &lt;strong&gt;75 Issues&lt;/strong&gt;,   (7+2+69+6) = &lt;strong&gt;84 Pull Requests&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;ruby-rails:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Ruby + Rails:&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;(871 + 412) = &lt;strong&gt;1283 Issues&lt;/strong&gt;, (119 + 464) = &lt;strong&gt;583 Pull Requests&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr&gt;

&lt;p&gt;Feel free to draw your own conclusions on presented facts. I&amp;rsquo;m biased and you should be careful just taking my words as the only valid perspective.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll try my short resume:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Because of the functional nature of Elixir the resulting code makes &lt;strong&gt;bugs easier to find and fix&lt;/strong&gt;, while at the same time the Erlang VM makes &lt;strong&gt;fast and highly robust unit tests possible&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The language designer (Jose Valim) is also shaping the web framework, that results in &lt;strong&gt;high cohesion and interdependent influence of Elixir and Phoenix&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Considered alone any of those facts does not make a big difference, but combined they allow to reach &lt;strong&gt;extraordinary developer productivity without sacrificing code quality in long term&lt;/strong&gt;.&lt;/p&gt;

&lt;hr&gt;

&lt;h3 id=&#34;elixir-provides-a-unique-and-unprecedented-opportunity-for-any-web-developer:248cf1be2829ed759d637ae6d7112e9b&#34;&gt;Elixir provides a unique and unprecedented opportunity for any web developer:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;prolific, energetic and humble&lt;/strong&gt; language designer who left one of the &amp;ldquo;hottest&amp;rdquo; developer communities to build the language for future web applications&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;battle-tested and highly optimized for robust distributed soft-realtime systems&lt;/strong&gt; runtime (BEAM - Erlang VM)&lt;/li&gt;
&lt;li&gt;huge focus on &lt;strong&gt;developer happiness&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;makes the right trade-offs between easy and simple, so you can always &lt;strong&gt;build more complex systems by combining simpler blocks&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fanatic and enthusiastic developer community&lt;/strong&gt;, welcoming beginners and making sure you get that experience of &lt;strong&gt;success by small baby steps&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Many developers are afraid when they hear the word &amp;ldquo;functional programming&amp;rdquo;&amp;hellip; You shouldn&amp;rsquo;t be.&lt;/p&gt;

&lt;p&gt;Just go to &lt;a href=&#34;http://elixir-lang.org/&#34;&gt;http://elixir-lang.org/&lt;/a&gt; and try it out.&lt;/p&gt;

&lt;p&gt;It takes only &lt;strong&gt;5 minutes to run your first Elixir code&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Watch videos, work with tutorials&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ask questions on &lt;strong&gt;Slack&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Become active contributer.&lt;/p&gt;

&lt;p&gt;Join your local &lt;strong&gt;Elixir Meetup&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Solve your next problem with Elixir and be amazed how it &lt;strong&gt;shapes your thinking&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Be prepared for the &lt;strong&gt;multi-core, parallel, concurrent, real-time future of software development&lt;/strong&gt;! Don&amp;rsquo;t miss out, because it is already here!&lt;/p&gt;

&lt;p&gt;All the best,
Roman&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Why Even Bother to Rewrite Your Rails Application in Elixir</title>
      <link>http://ruby2elixir.github.io/posts/2015/11-25-why-even-bother-to-rewrite-your-rails-application-in-elixir.html</link>
      <pubDate>Wed, 25 Nov 2015 18:36:00 +0100</pubDate>
      
      <guid>http://ruby2elixir.github.io/posts/2015/11-25-why-even-bother-to-rewrite-your-rails-application-in-elixir.html</guid>
      <description>&lt;p&gt;Hey there, I believe that our future as web software development is going to change soon.
There is a lot of ways to write software and I have chosen to write web applications. &lt;strong&gt;My goal is to build my own SaaS business soon and be responsible for it&lt;/strong&gt;. When you have that perspective you treat any superficial level of &lt;strong&gt;complexity as unacceptable&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;This is the reason why in 2007 I have learned Ruby and why I wrote my first web applications in Rails. I had to be able to &lt;strong&gt;maintain my applications in the long run&lt;/strong&gt;. To peek behind the curtain, I chose a &lt;strong&gt;path of apprenticeship&lt;/strong&gt; and joined a then young startup named &lt;strong&gt;DaWanda and watched it grow from 12 people to 200 people&lt;/strong&gt;. It grew from a single largish Rails app deployed on 5 dedicated server to a beast of multiple apps with &lt;strong&gt;slow test suites&lt;/strong&gt; and &lt;strong&gt;plenty of moving parts&lt;/strong&gt;&amp;hellip; To keep the thing running required quite a lot mental effort and it was a dedicated job in itself. You build &lt;strong&gt;abstractions upon abstractions and depend on a hefty amount of third-party libraries just to keep your application alive&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Timeouts, network partitions, lots of small inconsistencies, memory leaks, hanging processes&lt;/strong&gt; : it all becomes your daily business.&lt;/p&gt;

&lt;p&gt;This is not how I envision my own applications in the future&amp;hellip; They should &lt;strong&gt;fit into my little brain&lt;/strong&gt;. They should grow with grace, be maintainable, resource-efficient, provide just the right abstractions to help me in the beginning, but &lt;strong&gt;get out of the way when I&amp;rsquo;m going against recommendations&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Playing with different languages showed some promise, but the &lt;strong&gt;lost productivity compared to Rails was hard to justify&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;That is until Elixir + Phoenix happened.&lt;/p&gt;

&lt;p&gt;It was not an instant insight, rather a slow process. You discover the author&amp;rsquo;s intents while solving small problems, you gather all the small bits of wisdom in discussions, you always ask the same question: &amp;ldquo;Where is the catch? It this too good to be true?&amp;rdquo;. So, I&amp;rsquo;m a &lt;strong&gt;careful &amp;ldquo;buyer&amp;rdquo; into new technogy&lt;/strong&gt;, there is just too much &amp;ldquo;innovation&amp;rdquo; happening right now.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m &lt;strong&gt;in this game for a long run&lt;/strong&gt;, so &lt;strong&gt;cutting corners in the beginning only to slow down in the future&lt;/strong&gt; is not an option.&lt;/p&gt;

&lt;p&gt;I also don&amp;rsquo;t want to buy into the &amp;ldquo;microservices&amp;rdquo; craziness that is all the range right now, you need many teams to compensate the trade-offs of that approach.&lt;/p&gt;

&lt;p&gt;I want a technology that will help me to ship products with certain guarantees.&lt;/p&gt;

&lt;p&gt;It should:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;be easily composable&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scale vertically&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;scale horizontally&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;be reliable&lt;/li&gt;
&lt;li&gt;be introspectable&lt;/li&gt;
&lt;li&gt;have great tooling&lt;/li&gt;
&lt;li&gt;provide &lt;strong&gt;productivity during development&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;provide &lt;strong&gt;productivity during production&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I am absolutely sure that &lt;strong&gt;Elixir/OTP&lt;/strong&gt; is currently &lt;strong&gt;THE ONLY LANGUAGE / PLATFORM&lt;/strong&gt; that gives you all that in a nice package.&lt;/p&gt;

&lt;p&gt;But it is hard to convince fellow developers when they see their cozy &amp;ldquo;Ruby&amp;rdquo; world threatened. &amp;ldquo;Why?&amp;rdquo; they say. &amp;ldquo;I&amp;rsquo;m totally fine with Rails. It solves my problems and that&amp;rsquo;s enough.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well&amp;hellip; The world is evolving. The applications of future demand to be more reliable, more realtime, much faster, cope with much more traffic from many more devices than today.&lt;/p&gt;

&lt;p&gt;Rails offers no solution for distributed systems - embrace the &lt;strong&gt;majestic monolith&lt;/strong&gt;. No solution for concurrent systems - &lt;strong&gt;background jobs as a poor abstraction&lt;/strong&gt; e.g Sidekiq. No reliable solution for realtime systems - &lt;strong&gt;ActionCable is a hack&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;And it is not Rails&amp;rsquo; fault, really. Ruby as a Virtual Machine helps you in the beginning, but &lt;strong&gt;hinders you when your application matures&lt;/strong&gt;. When you outgrow that single Rails app. When it&amp;rsquo;s time to break it apart. Be prepared for the &lt;strong&gt;zoo of technologies&lt;/strong&gt; just to keep it somehow alive. And let me tell you one thing: you will probably never feel like you control the system.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s ok, you will earn money with it. And Rails is not dying, as some might say.&lt;/p&gt;

&lt;p&gt;It just got&amp;hellip; Well&amp;hellip; Old.&lt;/p&gt;

&lt;p&gt;Not appropriate for the future we are about to face.&lt;/p&gt;

&lt;p&gt;Ambitious, demanding apps require modern tooling and new approaches. The world is realtime.&lt;/p&gt;

&lt;p&gt;It is &lt;strong&gt;hard to scale Rails apps and keep quality up&lt;/strong&gt;. Usually you&amp;rsquo;ll end up &lt;strong&gt;hiding behind caching&lt;/strong&gt;, like MemCached, Redis, Varnish, Fastly&amp;hellip; That&amp;rsquo;s it. And you&amp;rsquo;ll spent a lot of time &lt;strong&gt;ironing all the bugs that occur only in production&lt;/strong&gt; and you will have a lot of hard time doing that. You&amp;rsquo;ll have to employ &lt;strong&gt;large teams of developers later in the game to overcome limitation of Rails&lt;/strong&gt;. And maybe you&amp;rsquo;ll fine with that, because that is the current state of affairs in the industry. Many decide to &lt;strong&gt;jump ship and build microservice architectures&lt;/strong&gt;. But there is &lt;strong&gt;no free lunch&lt;/strong&gt; here, you&amp;rsquo;ll still need multiple teams of developers responsible for them. And it certainly requires quite &lt;strong&gt;a lot of unlearning and patience to become even slightly productive with that approach&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Elixir + Phoenix combo gives you both: &lt;strong&gt;write as monolithic app now, easily split up into several applications later&lt;/strong&gt;, use Erlang VM as &lt;strong&gt;operating system to write your application&lt;/strong&gt;. Currently there is &lt;strong&gt;no alternative for that approach&lt;/strong&gt; that is more elegant and efficient.&lt;/p&gt;

&lt;p&gt;Watch this space closely, &lt;strong&gt;Elixir is gaining steam with incredible speed&lt;/strong&gt; and will surpass Rails in 2-3 years easily.&lt;/p&gt;

&lt;p&gt;Phoenix is &lt;strong&gt;not a clone of Rails&lt;/strong&gt;, it is the ultimate combination of years of experience with demanding Rails applications combined into a very &lt;strong&gt;robust, simple, extensible and highly performant package&lt;/strong&gt;, standing on shoulders of over 30 years experience building &lt;strong&gt;highly available soft-realtime systems&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;It is very hard to top that.&lt;/p&gt;

&lt;p&gt;Think like a professional and &lt;strong&gt;invest in your future now&lt;/strong&gt;. Go to &lt;a href=&#34;http://elixir-lang.org/learning&#34;&gt;http://elixir-lang.org/learning&lt;/a&gt; and learn Elixir, you wont regret this decision a single minute. I certainly did not!&lt;/p&gt;

&lt;p&gt;Cheers and all the best,
Roman&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>